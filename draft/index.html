<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Understanding JavaScriptCore&#39;s DFG Optimizing Compiler: IR and Frontend | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="The DFG (Data Flow Graph) optimizing JIT compiler is one of the main performance drivers of JavaScriptCore (JSC), the Javascript engine in WebKit. In this post, we will explore the interesting designs">
<meta property="og:type" content="website">
<meta property="og:title" content="Understanding JavaScriptCore&#39;s DFG Optimizing Compiler: IR and Frontend">
<meta property="og:url" content="draft/index.html">
<meta property="og:site_name">
<meta property="og:description" content="The DFG (Data Flow Graph) optimizing JIT compiler is one of the main performance drivers of JavaScriptCore (JSC), the Javascript engine in WebKit. In this post, we will explore the interesting designs">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-07-31T00:00:00.000Z">
<meta property="article:modified_time" content="2022-08-03T09:49:41.547Z">
<meta property="article:author" content="Haoran Xu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../atom.xml" title="" type="application/atom+xml">
  
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
    
<link rel="stylesheet" href="../css/source_code_pro.css">

  

  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">-->
  
<link rel="stylesheet" href="../css/bootstrap/bootstrap.min.css">


  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="../css/styles.css">

  

  
  <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->
  
<script src="../js/jquery.min.js"></script>


<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="../index.html">Home</a></li>
        
          <li><a class=""
                 href="../archives/">Archives</a></li>
        
          <li><a class=""
                 href="../about/">About</a></li>
        
          <li><a class=""
                 href="../cnblog/">Chinese Blog</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title"></h1>
  
    <p class="blog-description">「こんなきれいな星も、やっぱりここまで来てから、見れたのだと思うから。だから・・もっと遠くへ・・」</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="page-" class="article article-type-page" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Understanding JavaScriptCore&#39;s DFG Optimizing Compiler: IR and Frontend
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="" class="article-date"><time datetime="2022-07-31T00:00:00.000Z" itemprop="datePublished">2022-07-31</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>The DFG (Data Flow Graph) optimizing JIT compiler is one of the main performance drivers of JavaScriptCore (JSC), the Javascript engine in <a href="https://webkit.org/" target="_blank" rel="noopener">WebKit</a>. In this post, we will explore the interesting designs around the intermediate representation (IR) used by DFG, and DFG’s frontend that translates the interpreter bytecode of a Javascript program into the DFG IR.</p>
<p>Let’s start with some necessary background knowledge.</p>
<h4 id="The-Purpose-of-the-DFG-Compiler">The Purpose of the DFG Compiler</h4>
<p>Javascript is a dynamic type langauge, so everything, for example <code>a + b</code>, can have a wild range of behaviors (e.g., number addition, string concatenation, function calls, etc), depending on the runtime type of the operands. This has two implications. First, every operation needs a big switch on the operand types, which is terribly slow. Second, the wild range of behaviors block nearly every optimization: for example, since <code>a + b</code> could end up with a function call, which could literally do anything, there is barely any invariant that the optimizer can deduce for optimization.</p>
<p>DFG solves the challenge through two techniques: <em>type speculation</em> and <em>OSR exit</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. The crucial observation is the following: in most practical programs, the operand types for a given program site are predictable. For example, it’s rare that an <code>a + b</code> is executed in a loop where <code>a</code> is sometimes a number, sometimes a string, and sometimes an object.</p>
<p>This is where <em>type speculation</em> comes in. If we speculate that an <code>a + b</code> at a program site is likely a numeric add, we only <em>check</em> at runtime that <code>a</code> and <code>b</code> are numbers, instead of running a big switch. If the check fails at runtime (which is unlikely), we will bail out from the optimized program, and continue execution in interpreter – this is called an <em>OSR exit</em>.</p>
<p>It’s important to note that an <em>OSR exit</em> is different from a slow path: in an OSR exit, we bail out from the optimized code and never return to it. This solves the second challenge above, as the compiler is safe to do optimizations after <code>a + b</code> based on the assumption that <code>a + b</code> is a numeric add (so that it knows <code>a</code> and <code>b</code> must be numeric, and <code>a + b</code> has no side effects, for example): if the assumption turns out to be false at runtime, since we will bail out from the code, none of the later code relying on the false assumption will be executed.</p>
<p>Type speculation and OSR exit open up opportunities for more optimizations. For example, consider <code>c = a + b; d = a + c</code>. If <code>a + b</code> is speculated to be a numeric add, we know for sure <code>a</code>, <code>b</code> and <code>c</code> must be numbers after the operation (as otherwise we would have OSR-exited). So now we know for sure the expression <code>a + c</code> is also a numeric add, so it needs no type check at all.</p>
<p>However, OSR exit poses unique challenges to DFG’s design. Specifically, at every point where an OSR exit is possible, we must know where in the interpreter<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> we should jump to and continue execution so that all program semantics are preserved, and how we can transform the optimized function’s stack frame to exactly the layout expected by the interpreter at that specific point. Therefore, DFG needs to generate OSR exit information (which are called <em>stackmaps</em> in JSC) for each potential OSR exit point. How DFG supports OSR exit will be one of the central topics of this post.</p>
<p>Another design requirement for the DFG IR is performance. The optimized code cannot run until it is generated, so one must balance compilation time and execution performance. JSC employs a four-tier strategy – interpreter, baseline compiler, the DFG compiler, and the FTL compiler, with each tier having a longer compilation time than the previous tier, but also generates better code. As the third tier in the hierarchy, the DFG compiler is supposed to compile fast while also producing decent code, leaving only the most heavyweight and time-consuming optimizations to the FTL tier. Therefore, the DFG IR must be fast to construct and transform (so that compilation is fast), while also exposing a lot of optimization opportunities (so that the generated code is good).</p>
<p>Finally, DFG’s design needs to support tiering-up. There are two cases:</p>
<ol>
<li>The baseline tier needs to tier up to DFG when the code becomes hot enough. Normally this happens at function level (when a call happens, if the callee has a DFG-compiled version, it will be executed), but JSC also supports entering a DFG-compiled function at a loop entry. That is, a function can be originally executing in baseline tier, but when the DFG-compiled code becomes ready, at the start of an outer-most loop, one can jump into the middle of the DFG-compiled code and continue execution in the DFG tier.</li>
<li>The DFG tier itself needs to tier up to the FTL tier, and similar to above, this can also happen at both function entry and loop entry.</li>
</ol>
<p>In JSC, tiering up at the start of a loop (instead of normally at function entry) has its own terminology called <em>OSR Entry</em>. It is also known as <em>hot loop transfer</em>.</p>
<h4 id="The-Interpreter-Bytecode">The Interpreter Bytecode</h4>
<p>To run a Javascript program, the first step is to invoke the parser to translate the program into a bytecode representation. JSC’s bytecode is <a href="https://en.wikipedia.org/wiki/Register_machine" target="_blank" rel="noopener">register-based</a>: each function’s call frame is essentially a vector of “slots”, with each slot (aka, virtual register) holding a Javascript value – be it a number, a string, an object, a function, and so on. Each bytecode instruction reads its inputs from the slots and writes its outputs into the slots. For example, an <code>Add</code> bytecode with <code>lhs=0</code>, <code>rhs=1</code>, and <code>output=2</code> will read the left-hand-side operand from slot <code>0</code>, the right-hand-side operand from slot <code>1</code>, perform the addition, and write the result into slot <code>2</code>.</p>
<p>The real situation is slightly more complex:</p>
<ol>
<li>We need somewhere to store the arguments, and since Javascript supports <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noopener">variadic arguments</a>, we can’t statically know how many arguments we have. So if we simply store the arguments starting at slot <code>0</code>, we won’t be able to safely write any slot without risking clobbering some argument. To solve this problem, in JSC, the arguments are stored using the negative slot indices.</li>
<li>The call frame needs to store some <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/interpreter/CallFrame.h.html#JSC::CallFrameSlot" target="_blank" rel="noopener">more information</a>, such as what function it is running, where its caller’s call frame is, which bytecode in the caller’s bytecode sequence it should returns to, etc. So each call frame also has a <code>CallFrameHeader</code> to store those information, which sits between the negative slot indices for arguments and the non-negative slot indices for locals.</li>
</ol>
<p><a name="InterpreterCallFrameLayout"></a>Conceptually, each call frame of a Javascript function looks like below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slot #  | ..  -4 | -3 | -2 | -1 | CallFrameHeader  |  0  |  1    ..</span><br><span class="line">Meaning | .. arg4 arg3 arg2 arg1  prev    ...      local0 local1 ..</span><br><span class="line">                                    | (other info) ^</span><br><span class="line">&lt;-- points to caller&#39;s call frame --&#x2F;       call frame pointer</span><br></pre></td></tr></table></figure>
<p>That is, the call frame pointer points at slot <code>0</code>. The <code>CallFrameHeader</code> sits right before slot <code>0</code>, and all the arguments are stored right before the <code>CallFrameHeader</code> in reversed order. Notably, the header contains a pointer to the caller’s call frame, so one can walk through every call frame in the stack by chasing that pointer.</p>
<p>The bytecode representation is the <em>single source of truth</em> of a Javascript program. Moreover, since a call frame (or a stack of call frames) is merely a vector of slots, this allows the optimizing compiler to easily reconstruct the call frame(s) that are expected by the interpreter, facilitating the implementation of OSR exit – a must need for the DFG and FTL compiler.</p>
<p>Now we are ready to explore the design of the DFG compiler frontend. DFG is a method JIT, so the compiler takes the function to compile, and generates the executable code for that function. The DFG frontend is responsible for transforming the JSC bytecode of the input function to DFG IR, which is subsequently passed to the DFG optimizer.</p>
<h4 id="The-DFG-Intermediate-Representation-IR">The DFG Intermediate Representation (IR)</h4>
<p>The interpreter bytecode is easy to understand and generate, has a compact sequential runtime representation, and offers a straightforward call frame layout which is important for OSR exit. However, it is not a suitable representation for optimization. Therefore, DFG uses a graph-based intermediate representation (IR) to represent the input program.</p>
<p>It’s worth noting that the DFG IR is as high-level as the bytecode. In fact, each kind of bytecode instruction generally has a one-to-one correspondence with a DFG IR node kind: if the bytecode is named <code>op_foo_bar</code> in the code, then the corresponding DFG IR node kind is usually named <code>FooBar</code>. Being high-level allows DFG to represent the program using a small number of IR nodes, which is important for the compiler to run fast.</p>
<p>The IR in DFG is very similar to the well-known <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener">SSA representation</a>. However, intentional deviations are made to enable faster construction, analysis and transformation of the IR than the stanford SSA form, which matches DFG’s purpose as a fast compiler.</p>
<p>Similar to SSA, each function is represented as a list of <a href="https://en.wikipedia.org/wiki/Basic_block" target="_blank" rel="noopener">basic blocks</a>, and each basic block contains a list of IR nodes. An IR node is also implicitly the SSA value it produces, and can be used as input to other IR nodes. However, unlike SSA, in DFG’s IR:</p>
<ol>
<li>The SSA value produced by an IR node can only be used by other IR nodes in the <strong>same</strong> basic block.</li>
<li>DFG does not have an IR node named <code>PHI</code>. Instead, in DFG’s IR, each function has a list of local variables that one can read from and write to.</li>
</ol>
<p>Due to the above two limitations, DFG IR can be thought as a <em>block-local SSA form</em>. That is, inside a block, DFG IR is very similar to SSA and also allows similar optimizations. But across the basic block boundary, data can only be communicated through local variables, which makes analysis and optimization harder than a standard SSA form.</p>
<p>DFG’s optimizer pipeline is designed around this representation to maximize its pros and minimize its cons: nearly every optimization pass in DFG is block-local. JSC’s empirical experience is that doing only block-local optimizations is already enough to generate decent code, while running faster than global optimizations.</p>
<p>Meanwhile, interestingly, since few optimizations in DFG work across basic blocks, the stack layout of DFG-generated code can be understood fairly easily at basic block boundaries. This makes <em>OSR Entry</em> a lot easier, as at the start of a basic block, the baseline code can easily transform its call frame layout to the layout that is expected by the DFG, and jumps into DFG to continue execution<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>. This is analoguous to how the simple layout of the interpreter call frame makes OSR Exit easier.</p>
<p>Despite that DFG IR focuses on block-local optimization, it nevertheless provided two mechanisms to track the data flow across basic-block boundaries: <code>VariableAccessData</code> and <em>auxillary PHI nodes</em>. We will explain <code>VariableAccessData</code> right now, but leave auxillary PHI nodes to a little bit later.</p>
<h4 id="VariableAccessData-Control-Flow-Sensitive-Local-Variables">VariableAccessData: Control-Flow-Sensitive Local Variables</h4>
<p>In DFG IR, <code>GetLocal</code> and <code>SetLocal</code> are not parametrized by the slot ordinal to read or write. Instead, the local variable to read or write is described by a <code>VariableAccessData</code> <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGVariableAccessData.h.html" target="_blank" rel="noopener">object</a>. The core invariant around <code>VariableAccessData</code> is as follow:</p>
<ol>
<li>In the DFG IR generated by the frontend, a <code>SetLocal</code> and a <code>GetLocal</code> has the same <code>VariableAccessData</code> pointer if and only if the value written by the <code>SetLocal</code> could flow to the <code>GetLocal</code> in the control flow graph.</li>
</ol>
<p>Therefore, <code>VariableAccessData</code> can be viewed as a more refined “slot ordinal” that works better for analysis, in the sense that different slot ordinals in the bytecode must correspond to different <code>VariableAccessData</code>, but the same slot ordinal doesn’t necessarily correspond to the same <code>VariableAccessData</code>. For example, consider the following snippet:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b = a + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// do something with b</span></span><br><span class="line">&#125;</span><br><span class="line">a = &#123; <span class="string">'x'</span> : <span class="string">'y'</span> &#125;;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> c = a.x;</span><br><span class="line">    <span class="comment">// do something with c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the bytecode, <code>a</code> could have slot ordinal <code>0</code> and both <code>b</code> and <code>c</code> could have slot ordinal <code>1</code> (since their lifetime do not overlap). If we only look at the slot ordinal number, we might reach the unfortunate conclusion that slot <code>0</code> is sometimes a number and sometimes an object, and slot <code>1</code> is sometimes a number and sometimes a string. However, in DFG’s IR, the first and second occurrences of <code>a</code> would share some <code>VariableAccessData</code> object <code>v1</code>, but the third and fourth occurrences of <code>a</code> would share a different <code>VariableAccessData</code> object <code>v2</code>. The accesses to <code>b</code> and <code>c</code> would also get different <code>VariableAccessData</code>, say <code>v3</code> and <code>v4</code>. This way, by identifying local variables with <code>VariableAccessData</code> instead of slot ordinals, the local variables in the DFG IR become control-flow sensitive, so type speculations can be more accurate.</p>
<p>The <code>VariableAccessData</code> information is generated through two steps. In the <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp" target="_blank" rel="noopener">first stage</a> where the bytecode is transformed to the DFG IR, the generated <code>VariableAccessData</code> are only <em>locally unified</em>. That is, the invariant for <code>VariableAccessData</code> only holds inside a basic block, and IR nodes in different basic blocks must have different <code>VariableAccessData</code> objects. The second stage, the <em>global unification pass</em>, analyze the control flow graph and unify the <code>VariableAccessData</code> in different basic blocks. We will focus on the former now, and return to the global unification pass later.</p>
<h4 id="Building-Block-Local-SSA-and-Locally-Unified-VariableAccessData">Building Block-Local SSA and Locally-Unified VariableAccessData</h4>
<p>It’s time to explain how we can transform the bytecode to DFG’s block-local SSA IR, while also building the locally-unified <code>VariableAccessData</code> in the process.</p>
<p>TODO</p>
<h4 id="Supporting-OSR-Exit">Supporting OSR Exit</h4>
<p>TODO</p>
<h4 id="Memory-Efficient-Stackmap-Representation">Memory-Efficient Stackmap Representation</h4>
<p>TODO</p>
<h4 id="The-Function-Inliner">The Function Inliner</h4>
<p>Function inlining is a critical optimization for any object oriented language to optimize away the OOP abstractions. In DFG, it is the frontend’s responsibility to make the inlining decisions and perform the inlining. That is, the <code>Call</code> bytecodes that the frontend decides to inline are gone in the generated DFG IR: you will not see the call, but only the DFG IR of the inlined functions. Inlining can be nested: functions called by an inlined function can also be inlined, up to a certain depth limit.</p>
<p>In a modern dynamic language like Javascript, however, since functions are first-class value, there is generally no way to statically know which function the code is calling. For example, when one writes <code>f()</code>, one is actually reading the value of the global variable <code>f</code> and then attempt to call that value. <code>f</code> could change value, and could be holding any value, including non-function values like <code>123</code>.</p>
<p>Therefore, inlining has to be speculative. For bytecode instructions that are perceived as reasonable to perform a call<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, such as the <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/bytecode/Opcode.h.html#_M/FOR_EACH_OPCODE_WITH_LLINT_CALL_LINK_INFO" target="_blank" rel="noopener">various</a> <code>Call</code> bytecodes, or object access that ends up calling <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="noopener">getters and setters</a>, the bytecode will record the list of different callees it has seen during execution in the interpreter tier and the baseline JIT tier. This is called <em>inline caching</em>: it not only allows DFG to make an educated speculation on the callee, but is also an important optimization on its own (though we won’t dive into it in this post). When DFG encounters such a bytecode that qualifies for inlining, it will inspect its inline cache to retrieve the observed callees. The list of call kinds that DFG considers for inlining can be found <a href="https://sillycross.github.io/r/WebKit/JavaScriptCore/PrivateHeaders/JavaScriptCore/InlineCallFrame.h.html#JSC::InlineCallFrame::Kind" target="_blank" rel="noopener">here</a>.</p>
<p>Now, there is another complexity. In Javascript, a function is really a function object, or a <em>closure</em>, as it captures the environment it was created in. So a function object contains:</p>
<ol>
<li>The actual Javascript code to be called.</li>
<li>The global environment associated with this closure.</li>
<li>The lexical environment captured by this closure.</li>
</ol>
<p>In JSC, each <code>(Code, GlobalEnv)</code> pair is represented by a <code>CodeBlock</code> (we simplified away some Javascript quirks here, see footnote<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>). For a given call site, DFG will consider inlining the callee in two cases:</p>
<ol>
<li>The observed callee is always the same function object.</li>
<li>The observed callees are different function objects, but share the same <code>CodeBlock</code> (this is common for the function factory pattern).</li>
</ol>
<p>For case 1, we need to check that the function object is our expected one, and OSR exit if the check fails. For case 2, we need to check that the <code>CodeBlock</code> stored in the function object is our expected one, and OSR exit if the check fails (note that case 1 is cheaper than case 2 since there is one less pointer dereference in the check, which is why we want to have two cases). Getters and setters are more complex as they need additional checks to ensure that the object access indeed results in the corresponding getter/setter call. Thanks to the check and the OSR exit, we know that the inlined code won’t be executed unless the callee is indeed the one we expected, so we can safely inline the callee’s implementation now.</p>
<p>Note that in both cases, the call ultimately ends up executing the same piece of Javascript code (though in case 2, the captured lexical environment can be different per call). Call sites that have observed more than one Javascript callees <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp.html#2123" target="_blank" rel="noopener">will not be inlined</a>. This is because DFG is positioned as a fast compiler. Emitting a branch and inlining multiple potential callees is technically possible, but would bloat up the code too much, which is not worthy in general.</p>
<p>Even if we have inlined a function, however, we still need to know that we are in an inlined function in some cases. First, exception handlers and stack tracers need to walk the stack, which must see the identical stack trace as the non-optimized version. Second, an OSR exit can happen inside an inlined function (or even a deeply nested inlined function). In that case, we need to restore the stack layout to the uninlined version exactly as expected by the interpreter and baseline JIT before we can bail out.</p>
<p>Fortunately, this is simplified by the fact that the stack can be simply viewed as a vector of slots. Therefore, we can translate the slot number in the callee’s bytecode into the slot number of the caller’s call frame, by simply adding a proper offset (this includes the callee’s <code>CallFrameHeader</code>, which can also be viewed as a few slots). For example, for a caller with <code>5</code> locals (slot <code>0</code> to <code>4</code>) and a callee taking <code>3</code> arguments, reference to the first, second, and third argument of the callee can be translated to slot <code>7</code>, <code>6</code>, <code>5</code> in the caller’s call frame respectively (look at the <a href="#InterpreterCallFrameLayout">call frame layout</a> if you are confused). This allows us to generate OSR exit information that is oblivious to inlining: the DFG frontend only emits information like “value <code>X</code> should be stored into slot number <code>Y</code> in the call frame when this OSR exit point triggers”, while the slot number <code>Y</code> could be actually an argument, a <code>CallFrameHeader</code> member, or a local of some arbitrarily deeply nested inlined function. This translation hides the complexity of inlining from the OSR exit logic and the rest of the DFG compiler, greatly simplifying things. We will explain how exactly the OSR exit information is generated and stored in the DFG IR in more detail later.</p>
<p>To summarize, after we emit the callee check, we need to fill the callee’s <code>CallFrameHeader</code> by generating DFG IR that writes proper information to the slot numbers which correspond to the callee’s <code>CallFrameHeader</code> (for example, see <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp.html#1693" target="_blank" rel="noopener">here</a>), so that the exception handlers and stack tracers can see the correct stack trace<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Note that the DFG optimizer is unaware of the stack walkers, so the write is also annotated as an <code>ImmediateNakedSet</code>, which prevents the DFG optimizer from optimizing it away or otherwise doing funny optimizations around it. We can then translate the callee’s bytecode to DFG IR, with the extra caution that when we generate OSR exit information inside the callee, we must translate the callee’s slot number to the caller’s slot number.</p>
<p>As always, the real story is more complex.</p>
<p>First, Javascript supports variadic arguments. Since we cannot statically know how many arguments we might have at runtime, we cannot statically translate the callee’s slot number into the caller’s slot number for OSR exit information. To solve this problem perfectly, we would need to make the OSR exit information aware of the number of variadic arguments at runtime and the inlining stack at every OSR exit point. This is way too complex for such a minor feature, so DFG made compromise instead. When it encounters a variadic function callee, it will set a limit on the maximum allowed number of variadic arguments based on profiling information. It then emits a runtime check, which OSR exit if the number of variadic arguments at runtime exceeds the limit. Now we have a statically known upper bound on the number of arguments, so we can translate the slot numbers again.</p>
<p>Second, Javascript supports <em>proper tail calls</em>. That is, the stack is guaranteed to have a bounded size no matter how many tail calls are executed. DFG supports inlining tail calls, but we will ignore this detail for simplicity.</p>
<p>Third, the speculated callee might not be a Javascript function, but an intrinsic (e.g., math functions <code>abs</code>, <code>round</code>, <code>floor</code>). Generally, DFG has one special IR node kind for each intrinsic (for example, the <code>ArithRound</code> IR node kind for the <code>round</code> intrinsic). This allows DFG to reason about the behavior of the intrinsic and perform optimizations. However, if the functionality of the intrinsic can already be represented using existing IR node kinds, DFG would generate the IR implementation for the intrinsic directly (for example <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp.html#2430" target="_blank" rel="noopener">here</a>).</p>
<p>Having explained <em>how</em> to do inlining, it’s time to explain <em>when</em> to do inlining.</p>
<p>DFG has not yet supported inlining for all Javascript features. So if a callee used <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGCapabilities.cpp.html#_ZN3JSC3DFG15capabilityLevelENS_8OpcodeIDEPNS_9CodeBlockEPKNS_11InstructionE" target="_blank" rel="noopener">such features</a> (for example, <code>yield</code>), it clearly cannot be inlined.</p>
<p>Beside that, it turns out that DFG’s strategy is surprisingly simple. For each function (before any inlining), define its “bytecode cost” as the total number of operands in the function’s bytecode. Then everything will be inlined as long as the following requirements are met:</p>
<ol>
<li>A function cannot be inlined if its bytecode cost is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp.html#_ZN3JSC3DFG14ByteCodeParser18getInliningBalanceERKNS_14CallLinkStatusENS_22CodeSpecializationKindE" target="_blank" rel="noopener">&gt;100 or 120</a>, depending on situation.</li>
<li>Nested inlining has a <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp.html#1634" target="_blank" rel="noopener">depth limit of 4</a>.</li>
<li>Each function can only recursively inline itself <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp.html#1641" target="_blank" rel="noopener">at most once</a>.</li>
<li>A function cannot inline any callee if its own bytecode cost is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGCapabilities.h.html#_ZN3JSC3DFG29isSmallEnoughToInlineCodeIntoEPNS_9CodeBlockE" target="_blank" rel="noopener">&gt;10000</a>.</li>
</ol>
<p>TODO: shouldNeverInline</p>
<h4 id="CPS-Rethreading-and-Auxillary-PHI-nodes">CPS Rethreading and Auxillary PHI nodes</h4>
<h4 id="The-Global-Unification-Pass">The Global Unification Pass</h4>
<h4 id="Summary">Summary</h4>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>OSR stands for <em>on-stack replacement</em>, a technique historically used by debuggers, but later found applications elsewhere, for example in the speculative JIT compilers here. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>In fact, we generally OSR-exit to the code generated by the baseline compiler, not the interpreter. But for the purpose of this post, we will ignore this complexity, as the baseline compiler uses the same stack layout as the interpreter, and talking about the interpreter is much easier to understand. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Of course it is not as easy as that sentence said, but we will defer the details to a future post. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>In Javascript, almost every operation can end up calling some function. However, most of them are exotic and hardly seen in practice. So while JSC needs to support such cases for standard compliance, JSC does not optimize for such cases. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>In Javascript, a function can be called either directly (<code>forCall</code> in JSC jargon), or through the <code>new</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">operator</a> (<code>forConstruct</code> in JSC jargon), and the two exhibits different behavior on the <code>this</code> variable. So in fact, one needs to use two different <code>CodeBlock</code>s to represent the normal-call case and the <code>new</code>-operator-call case. This is encapsulated by the class <code>FunctionExecutable</code>, which <a href="https://sillycross.github.io/r/WebKit/JavaScriptCore/PrivateHeaders/JavaScriptCore/FunctionExecutable.h.html#JSC::FunctionExecutable::m_codeBlockForCall" target="_blank" rel="noopener">contains</a> the two <code>CodeBlock</code>s. A function object in JSC stores the <code>FunctionExecutable</code> and its captured lexical environment. When a function object is called, one needs to use the correct <code>CodeBlock</code> in the <code>FunctionExecutable</code> based on whether the call is a normal call or a <code>new</code> operator call. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Note that not all fields in <code>CallFrameHeader</code> are populated: only the fields required by the exception handler and stack tracer to walk the stack are populated, since the optimized code itself doesn’t need these information. However, the rest of the fields still must be populated in case of an OSR exit: this is accomplished by emitting proper OSR exit information to populate those slots at OSR exit. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="draft/index.html" data-id="cl6dfh2px0003avor1ulzb2cm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
    

  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  


  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../archives/2022/">2022</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../archives/2021/">2021</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list-recent-posts">
      
        <li>
          <a href="../2022/07/18/2022-07-18/">How to check if a real number is an integer in C++?</a>
        </li>
      
        <li>
          <a href="../2022/06/11/2022-06-11/">Bizarre Performance Characteristics of Alder Lake CPU</a>
        </li>
      
        <li>
          <a href="../2022/06/02/2022-06-02/">Understanding GC in JSC From Scratch</a>
        </li>
      
        <li>
          <a href="../2022/05/31/2022-05-31/">NP70PNP + Ubuntu Tweak Notes</a>
        </li>
      
        <li>
          <a href="../2022/04/30/2022-04-30/">The Watchpoint Mechanism in JSC</a>
        </li>
      
    </ul>
  </div>




        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 Haoran Xu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>-->

<script src="../js/bootstrap/bootstrap.min.js"></script>



  
<link rel="stylesheet" href="../fancybox/jquery.fancybox.css">

  
<script src="../fancybox/jquery.fancybox.pack.js"></script>




<script src="../js/script.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
 

</body>
</html>
