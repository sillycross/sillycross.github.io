<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Understanding GC in JSC | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="THIS IS AN INCOMPLETED DRAFT. Javascript relies on the garbage collector (GC) to reclaim memory. In this post, we will dig a little bit into JSC (the Javascript engine of WebKit)&#39;s garbage collection">
<meta property="og:type" content="website">
<meta property="og:title" content="Understanding GC in JSC">
<meta property="og:url" content="draft/index.html">
<meta property="og:site_name">
<meta property="og:description" content="THIS IS AN INCOMPLETED DRAFT. Javascript relies on the garbage collector (GC) to reclaim memory. In this post, we will dig a little bit into JSC (the Javascript engine of WebKit)&#39;s garbage collection">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-15T00:00:00.000Z">
<meta property="article:modified_time" content="2022-05-25T02:56:00.127Z">
<meta property="article:author" content="Haoran Xu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../atom.xml" title="" type="application/atom+xml">
  
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
    
<link rel="stylesheet" href="../css/source_code_pro.css">

  

  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">-->
  
<link rel="stylesheet" href="../css/bootstrap/bootstrap.min.css">


  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="../css/styles.css">

  

  
  <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->
  
<script src="../js/jquery.min.js"></script>


<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="../index.html">Home</a></li>
        
          <li><a class=""
                 href="../archives/">Archives</a></li>
        
          <li><a class=""
                 href="../about/">About</a></li>
        
          <li><a class=""
                 href="../cnblog/">Chinese Blog</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title"></h1>
  
    <p class="blog-description">「こんなきれいな星も、やっぱりここまで来てから、見れたのだと思うから。だから・・もっと遠くへ・・」</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="page-" class="article article-type-page" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Understanding GC in JSC
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="" class="article-date"><time datetime="2022-05-15T00:00:00.000Z" itemprop="datePublished">2022-05-15</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>THIS IS AN INCOMPLETED DRAFT.</p>
<p>Javascript relies on the garbage collector (GC) to reclaim memory. In this post, we will dig a little bit into JSC (the Javascript engine of <a href="https://webkit.org/" target="_blank" rel="noopener">WebKit</a>)'s garbage collection system.</p>
<p>WebKit’s <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/" target="_blank" rel="noopener">blog post on GC</a> is a great post that explained the novelties of JSC’s GC and also positioned it within the context of various GC schemes in academia and industry. However, as someone with little GC background, I found WebKit’s blog post too hard to understand, and also too vague to understand the specific design used by JSC. So this blog post attempts to add in some more details.</p>
<p>The garbage collector in JSC is <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Moving_vs._non-moving" target="_blank" rel="noopener">non-compacting</a>, <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)" target="_blank" rel="noopener">generational</a> and mostly<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>-<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent" target="_blank" rel="noopener">concurrent</a>. On top of being concurrent, JSC’s GC heavily employs lock-free programming for better performance.</p>
<p>As we unfold the design, it’s likely that you want to question me:“Why is it designed this way, but not some other way?” However, understanding the correctness of a lock-free scheme is already no easy feat, not to mention optimizing it. Therefore, this post will first focus on understanding why JSC’s design is correct, only mark discussions on design motivation and alternatives like <sup>[Design Discussion N]</sup>. At the end, we will discuss the motivations behind the design decisions, the alternate designs possible and potential reasons that they are not chosen.</p>
<h4 id="Memory-Allocation-in-JSC">Memory Allocation in JSC</h4>
<p>Memory allocator and GC are by nature tightly coupled – allocator allocates memory to be reclaimed by GC, and GC frees memory to be reused by allocator. In this section, we will briefly introduce JSC’s memory allocators.</p>
<p>At the core of the memory allocation scheme in JSC is the data structure <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectory.h.html#JSC::BlockDirectory" target="_blank" rel="noopener">BlockDirectory</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. It implements a fixed-sized allocator, that is, an allocator that only allocates memory chunks of some fixed size <code>S</code>. The allocator keeps tracks of a list of fixed-sized (in current code, 16KB) memory pages (“blocks”) it owns, and a free list. Each block is divided into cells of size <code>S</code>, and has a footer at its end<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, which contains various metadata information needed for GC and allocator, e.g., which cells are free. By aggregating and sharing metadata at the footer, it both saves memory and improves performance of related operations: we will go into details later.</p>
<p>When a <code>BlockDirectory</code> needs to make an allocation, it tries to allocate from its free list. If the free list is empty, it tries to iterate through the blocks it owns<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, to see if it can find a block containing free cells. If yes, it <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle5sweepEPNS_8FreeListE" target="_blank" rel="noopener">scans the block footer metadata</a> to find out all the free cells<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> in this block, and put into the free list. Otherwise, it allocates a new block from the OS<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Note that this implies a <code>BlockDirectory</code>’s free list only contains cells in one block: this is called <code>m_currentBlock</code> in the code, and we will revisit this later.</p>
<p>In JSC there are three kinds of allocators:</p>
<ol>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/CompleteSubspace.h.html#32" target="_blank" rel="noopener">CompleteSubspace</a>: this is a segregated allocator responsible for allocating small objects (max size about 8KB). Specifically, there is a pre-defined list of exponentially-growing size-classes<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>, and one <code>BlockDirectory</code> is used to handle allocation for each size class. So to allocate an object, you find the smallest size class large enough to hold the object, and allocate from that size class.</li>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation" target="_blank" rel="noopener">PreciseAllocation</a>: this is used to handle large allocations that cannot be handled by <code>CompleteSubspace</code> allocator<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>. It simply relies on the standard (malloc-like) memory allocator, though in JSC a custom malloc implementation called <code>libpas</code> is used. The downside is that since <code>PreciseAllocation</code> is done on a per-object basis, it cannot aggregate and share metadata information of multiple objects together to save memory and improve performance (as <code>CompleteSubspace</code>’s block footer did). Therefore, every <code>PreciseAllocation</code> comes with a whopping overhead of a <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation" target="_blank" rel="noopener">96-byte GC header</a> to store the various metadata information needed for GC for this object (though this overhead is justified since each allocation is already at least 8KB).</li>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/IsoSubspace.h.html#JSC::IsoSubspace" target="_blank" rel="noopener">IsoSubspace</a>: each <code>IsoSubspace</code> is used to allocate objects of a fixed type with a fixed size. So each <code>IsoSubspace</code> simply holds a <code>BlockDirectory</code> to do allocation. This is mainly a security hardening feature that makes use-after-free-based attacks harder<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>.</li>
</ol>
<p>As you can see, <code>CompleteSubspace</code> is the most interesting part that handles the common case: small allocations. <code>IsoSubspace</code> can be considered a simplified <code>CompleteSubspace</code>, and <code>PreciseAllocation</code> is the rare slow path.</p>
<!-- However, since `PrecisionAllocation` is the slow path, the GC algorithm dealing with it is easier to understand. So we will first focus on how GC works on `PreciseAllocation`, and then discuss the performance optimizations designed for `CompleteSubspace`. -->
<h4 id="Generational-GC-Basics">Generational GC Basics</h4>
<p>In JSC’s generational GC model, each GC maybe either an eden GC or a full GC. The heap consists of a small “new space” (eden), holding the newly allocated objects, and a large “old space” holding the older objects that have survived one GC cycle. New objects are allocated in the eden. When the eden is full, an eden GC is invoked to garbage-collect the unreachable objects in eden. All the surviving objects in eden are then considered to be in the old space<sup><a href="#altdesign1">[Design Discussion 1]</a></sup>. To reclaim objects in the old space, a full GC is needed.</p>
<p>The effectiveness of the above scheme relies on the so-called “generational hypothesis”:</p>
<ol>
<li>Most objects collected by the GC are young objects (died when they are still in eden), so eden GC (which only collects the eden) is sufficient to reclaim most of the memory.</li>
<li>Pointers from old space to eden is much rarer than pointers from eden to old space or pointers from eden to eden, so an eden GC’s runtime is approximately linear to the size of the eden, as it only needs to start from a small subset of the old space. This implies that the cost of GC can be amortized by the cost of allocation.</li>
</ol>
<p>In JSC, every object managed by the GC has two kinds of markers:</p>
<ol>
<li>Every object managed by GC inherit the <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/runtime/JSCell.h.html#JSC::JSCell" target="_blank" rel="noopener">JSCell</a> class, which contains a 1-byte member <code>cellState</code>. This <code>cellState</code> is a color marker used by GC. It has <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/CellState.h.html#JSC::CellState" target="_blank" rel="noopener">three possible colors</a>: white, grey and black.</li>
<li>Every object also has two out-of-object mark bits: <code>isNewlyAllocated</code> and <code>isMarked</code>. For objects allocated by <code>PreciseAllocation</code>, the bits reside in the GC header. For objects allocated by <code>CompleteSubspace</code>, the bits reside in the block footer.</li>
</ol>
<p>Why do we want the outlined marks? Why can’t we steal two bits from <code>cellState</code> and store <code>isNewlyAllocated</code> and <code>isMarked</code> inline as well?</p>
<p>The inlined mark <code>cellState</code> is easy to access for the mutator thread (the thread executing Javascript code), since it is just a field in the object. However, it has bad memory locality for GC and allocators, which need to quickly traverse through all the marks of all objects in some block owned by <code>CompleteSubspace</code> (which is the common case). Outlined marks have the opposite performance characteristics: they are more expensive to access for the mutator thread, but since they are aggregated into bitvectors and stored in the block footer of each block, GC and allocators can traverse them really fast.</p>
<p>So JSC keeps both marks to get the better of both worlds: the mutator thread’s fast path will only concern the inlined mark <code>cellState</code>, while the GC and allocator logic can also take advantage of the memory locality of the outlined marks.</p>
<p>Of course, the cost of this is a more complex design… so we have to unfold it bit by bit.</p>
<h4 id="The-cellState-Mark">The cellState Mark</h4>
<p>Let’s ignore the outlined marks for now, and focus on the eden GC and the mutator thread first, which mainly only conerns about the inlined mark <code>cellState</code>.</p>
<p>The eden GC uses a breadth-first search to scan the eden space. An object’s <code>cellState</code> is black if it has been scanned, i.e., all its children has been put into the BFS queue. An object is grey if it is currently in the BFS queue. An object is white if it has not been touched by the scan yet. Notably, this implies that all objects in the old space are black.</p>
<p>In pseudocode, the logic for the marking phase of the eden GC is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">  JSCell* obj = <span class="built_in">queue</span>.pop();</span><br><span class="line">  obj-&gt;m_cellState = Black;</span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JsCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;m_cellState == White) &#123;    </span><br><span class="line">      child-&gt;m_cellState = Grey;</span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that the scan always mark an object black <em>before</em> it visits its children <sup><a href="#altdesign1">[Design Discussion 1]</a></sup>.</p>
<p>But where does the scan start, so that we can scan through every reachable object in eden? It turns out that there are two cases to consider:</p>
<ol>
<li>Of course, we need to push the GC roots to the initial queue.</li>
<li>If an object in the old space contains a pointer to an object in eden, we need to put the old space object to the initial queue<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>.</li>
</ol>
<p>The invariant for the second case is maintained by the mutator side. Specifically, whenever one writes a pointer slot of some object <code>A</code> in the heap to point to another object <code>B</code>, one needs to check if <code>A</code> is black and <code>B</code> is white. If so, one needs to put <code>A</code> into a <code>rememberedSet</code>. Eden GC must treat the <code>rememberedSet</code> as if they were GC roots. This is called a <code>WriteBarrier</code>.</p>
<p>However, in JSC, the <code>WriteBarrier</code> only checks if <code>A</code> is black: it doesn’t concern if <code>B</code> is white. We will leave the discussion of this design choice to <sup><a href="#altdesign1">[Design Discussion 1]</a></sup>.</p>
<p>In pseudocode, the logic for a WriteBarrier is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed after one writes a pointer into a field of 'obj'</span></span><br><span class="line"><span class="keyword">if</span> (obj-&gt;m_cellState == Black) &#123;</span><br><span class="line">  addToRememberedSet(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Getting-Concurrent-–-cellState-Mark">Getting Concurrent – cellState Mark</h4>
<p>In JSC, the marking phase runs concurrently with the mutator thread, and they both access the <code>cellState</code>. JSC does not want to use a lock for performance reasons, so interesting race condition between mutator’s <code>WriteBarrier</code> and GC’s marking logic rises.</p>
<p>Suppose <code>o</code> is an object, and the mutator wants to store a pointer to another object <code>target</code> into a field <code>f</code> of <code>o</code>. The marking logic of GC wants to scan <code>o</code> and append its children into the queue. Since <code>target</code> may be in eden, we need to make sure that eden GC will observe the <code>o -&gt; target</code> pointer link.</p>
<p>Let’s first look at the correct logic:</p>
<div>
<div style="float:left; width:50%; border-right: solid 1px; border-bottom: solid 1px; background-color:#FFCB9A">
<div style="margin-left:10px; ">
Mutator (WriteBarrier)
</div>
</div>
<div style="float:left; width:50%; border-bottom: solid 1px; background-color:#A8B545">
<div style="margin-left:10px;">
GC (Marker) 
</div>
</div>
</div>
<div>
<div style="float:left; width:50%; border-right: solid 1px;">
<div style="margin-left:10px; ">
Store(o.f, target)<br>
StoreLoadFence()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// WriteBarrier begin<br>                               
t1 = Load(o.cellState)<br>
if (t1 == Black): addToRememberedSet(o)
</div>
</div>
<div style="float:left; width:50%;">
<div style="margin-left:10px;">
Store(o.cellState, Black)<br>
StoreLoadFence()<br>
t2 = Load(o.f)<br>
queue.append(t2)&nbsp;&nbsp;// some if-check omitted<br>
</div>
</div>
</div>
<div style="display: table; clear: both;"</div>
<br>
<p>This is mostly just a copy of the pseudocode in the above section, except that we have two <code>StoreLoadFence()</code>. A <code>StoreLoadFence()</code> guarantees that no <code>LOAD</code> after the fence may be executed by the CPU out-of-order engine until all <code>STORE</code> before the fence have completed. Let’s first analyze what could go wrong without either of the fences.</p>
<p>Just to make things perfectly clear, the precondition before the code is <code>o.cellState = Grey</code> (because <code>o</code> is in the GC’s BFS queue) and <code>o.f = someOldValue</code>.</p>
<p>What could go wrong if the mutator WriteBarrier doesn’t have the fence? Without the fence, the CPU can execute the <code>LOAD</code> in line 3 before the <code>STORE</code> in line 1. Then, in the following interleaving:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Grey</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
</ol>
<p>Now, the mutator did not add <code>o</code> to remembered set (because <code>t1</code> is Grey, not Black), and <code>t2</code> in GC is the old value in <code>o.f</code> instead of <code>target</code>, so GC did not push <code>target</code> into the queue. So the pointer link from <code>o</code> to <code>target</code> is missed in GC. This can result in <code>target</code> being wrongly reclaimed despite it is live.</p>
<p>And what could go wrong if the GC marking logic doesn’t have the fence? Similarly, without the fence, the CPU can execute the <code>LOAD</code> in line 3 before the <code>STORE</code> in line 1. Then, in the following interleaving:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Grey</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
</ol>
<p>Similar to above, mutator sees <code>t1 = Grey</code> and GC sees <code>t2 = oldValue</code>. So <code>o</code> is not added to remembered set, and <code>target</code> is not pushed into the queue, the pointer link is missed.</p>
<p>Finally, let’s analyze why the code behaves correctly if both fences are present. Unfortunately there is not a better way than manually enumerating all the interleavings. Thanks to the fences, <code>Mutator Line 1</code> must execute before <code>Mutator Line 3</code>, and <code>GC Line 1</code> must execute before <code>GC Line 3</code>, but the four lines can otherwise be reordered arbitrarily. So there are <code>4! / 2! / 2! = 6</code> possible interleavings. So let’s go!</p>
<p>Interleaving 1:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Grey</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>In this interleaving, the mutator did not add <code>o</code> to remembered set, but the GC sees <code>target</code>, so it’s fine.</p>
<p>Interleaving 2:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Black</div>
</li>
</ol>
<p>In this interleaving, GC saw the old value, but the mutator added <code>o</code> to the remembered set, so GC will eventually drain from the remembered set and scan <code>o</code> again, at which time it will see the correct new value <code>target</code>, so it’s fine.</p>
<p>Interleaving 3:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Black</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>In this interleaving, GC saw the new value <code>target</code>, nevertheless, the mutator saw <code>t1 = Black</code> and added <code>o</code> to the remembered set. This is unfortunate since GC will scan <code>o</code> again, but it doesn’t affect correctness.</p>
<p>Interleaving 4:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Black</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>Interleaving 5:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Black</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>Interleaving 6:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, Black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = Black</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Brief stop-the-world pause is still required at the start and end of each GC cycle, and may be intentionally performed if the mutator thread (i.e. the thread running Javascript code) is producing garbage too fast for the GC thread to keep up with. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>The actual allocation logic is implemented in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.h.html#JSC::LocalAllocator" target="_blank" rel="noopener">LocalAllocator</a>. Despite that in the code <code>BlockDirectory</code> is holding a linked list of <code>LocalAllocator</code>, (at time of writing, for the codebase version linked in this blog) the linked list always contains exactly one element, so the <code>BlockDirectory</code> and <code>LocalAllocator</code> is one-to-one and can be viewed as an integrated component. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Since the footer resides at the end of a block, one can do a simple bit math from any object pointer to access the footer of the block it resides in. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Similar to that per-cell information is aggregated and stored in the block footer, per-block information is aggregated as bitvectors and stored in <code>BlockDirectory</code> for fast lookup. Specifically, two bitvectors <code>empty</code> and <code>canAllocateButNotEmpty</code> track if a block is empty, or partially empty. The <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectoryBits.h.html#_M/FOR_EACH_BLOCK_DIRECTORY_BIT" target="_blank" rel="noopener">code</a> is relatively confusing because the bitvectors are <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectoryBits.h.html#JSC::BlockDirectoryBits::Segment" target="_blank" rel="noopener">layouted in a non-standard way</a> to make resizing easier, but conceptually it’s just one bitvector for each boolean per-block property. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>While seemingly straightforward, it is not straightforward at all (as you can see in the code). The free cells are marked free by the GC, and due to concurrency and performance optimization the logic becomes very tricky: we will revisit this later. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>In fact, it also <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.cpp.html#195" target="_blank" rel="noopener">attempts to steal</a> blocks from other allocators, and the OS memory allocator may have <a href="https://sillycross.github.io/r/WebKit/WTF/Headers/wtf/Gigacage.h.html" target="_blank" rel="noopener">some special requirements</a> required for the VM, but we ignore those details for simplicity. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>In the current implementation, the list of sizes (byte) are 16, 32, 48, 64, 80, then <code>80 * 1.4 ^ n</code> for <code>n &gt;= 1</code> up to about 8KB. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>An interesting implementation detail is that <code>IsoSubspace</code> and <code>CompleteSubspace</code> always return memory aligned to 16 bytes, but <code>PreciseAllocation</code> always return memory address that has reminder 8 module 16. This allows identifying whether an object is allocated by <code>PreciseAllocation</code> with a simple bit math. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Memory of an <code>IsoSubspace</code> is only used by this <code>IsoSubspace</code>, never stolen by other allocators. As a result, a memory address in <code>IsoSubspace</code> can only be reused to allocate objects of the same type. So for any type <code>A</code> allocated by <code>IsoSubspace</code>, even if there is a use-after-free bug on type <code>A</code>, it is impossible to allocate <code>A</code>, free it, allocate type <code>B</code> at the same address, and exploit the bug to trick the VM into interpreting an integer field in <code>B</code> controlled by attacker as a pointer field in <code>A</code>. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Note that we push the old space object into the queue, not the eden object, because this pointer could have been overwritten at the start of the GC cycle, making the eden object potentially collectable. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="draft/index.html" data-id="cl3kzww310003bhn471w796jt" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
    

  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  


  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../archives/2022/">2022</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../archives/2021/">2021</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="../2022/04/30/2022-04-30/">The Watchpoint Mechanism in JSC</a>
        </li>
      
        <li>
          <a href="../2022/04/26/2022-04-26/">Note on x86-64 Memory Model</a>
        </li>
      
        <li>
          <a href="../2022/04/01/2022-04-01/">From X Macro to FOR_EACH to Cartesian Product Enumeration with C Macro</a>
        </li>
      
        <li>
          <a href="../2021/10/24/2021-10-24/">Some Random Thoughts</a>
        </li>
      
        <li>
          <a href="../2021/09/20/2021-09-20/">Understanding JavaScriptCore&#39;s DFG JIT: CPS Rethreading Pass</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 Haoran Xu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>-->

<script src="../js/bootstrap/bootstrap.min.js"></script>



  
<link rel="stylesheet" href="../fancybox/jquery.fancybox.css">

  
<script src="../fancybox/jquery.fancybox.pack.js"></script>




<script src="../js/script.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
 

</body>
</html>
