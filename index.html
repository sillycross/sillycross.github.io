<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title></title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title">
<meta property="og:url" content="index.html">
<meta property="og:site_name">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Haoran Xu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
    
<link rel="stylesheet" href="css/source_code_pro.css">

  

  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">-->
  
<link rel="stylesheet" href="css/bootstrap/bootstrap.min.css">


  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="css/styles.css">

  

  
  <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->
  
<script src="js/jquery.min.js"></script>


<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="">Home</a></li>
        
          <li><a class=""
                 href="archives/">Archives</a></li>
        
          <li><a class=""
                 href="about/">About</a></li>
        
          <li><a class=""
                 href="cnblog/">Chinese Blog</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title"></h1>
  
    <p class="blog-description">「こんなきれいな星も、やっぱりここまで来てから、見れたのだと思うから。だから・・もっと遠くへ・・」</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-2022-07-18" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/07/18/2022-07-18/">How to check if a real number is an integer in C++?</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2022/07/18/2022-07-18/" class="article-date"><time datetime="2022-07-18T00:00:00.000Z" itemprop="datePublished">2022-07-18</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>I have a <code>double</code>, and I want to know if its value is an integer that fits in a <code>int64_t</code>. How can I do it in C++?</p>
<p>Ask any C++ newbie, and you will get an obvious “answer”: cast your <code>double</code> to <code>int64_t</code>, then cast it back to <code>double</code>, and compare if it equals your original number.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInt64</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d == <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But is it really correct? Let’s test it:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, IsInt64(<span class="number">1e100</span>) ? <span class="string">"1"</span> : <span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>and <a href="https://godbolt.org/z/r8j98rKqd" target="_blank" rel="noopener">here’s the output</a> under <code>clang -O3</code> (latest version 14.0.0):</p>
<p><img src="/images/2022-07-18/output1.png" alt="(a bunch of junk characters that varies from run to run)"></p>
<p>!@#$%^&amp;… Why? Shouldn’t it at least print either a <code>1</code> or a <code>0</code>?</p>
<h3 id="The-Undefined-Behavior">The Undefined Behavior</h3>
<p>Here’s the reason: when you cast a floating-point value to an integer type, <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Floating.E2.80.93integral_conversions" target="_blank" rel="noopener">according to C/C++ standard</a>, if the integral part of the value does not fit into the integer type, the behavior is undefined (by the way, casting special floating-point values <code>NaN</code>, <code>INF</code>, <code>-INF</code> to integer is also undefined behavior).</p>
<p>And unfortunately, Clang did the least helpful thing in this case:</p>
<ol>
<li>It inlined the function <code>IsInt64</code>, so <code>IsInt64(1e100)</code> becomes expression <code>1e100 == (double)(int64_t)1e100</code>.</li>
<li>It deduces that <code>(int64_t)1e100</code> incurs undefined behavior since <code>1e100</code> does not fit into <code>int64_t</code>, so it evaluates to a special <code>poison</code> value (i.e., undefined).</li>
<li>Any expression on a <code>poison</code> value also produces <code>poison</code>. So Clang deduces that expression <code>IsInt64(1e100) ? &quot;1&quot; : &quot;0&quot;</code> ultimately evaluates to <code>posion</code>.</li>
<li>As a result, Clang deduces that the second parameter to <code>printf</code> is an undefined value. So in machine code, the whole expression is “optimized out”, and whatever junk stored in that register gets passed to <code>printf</code>. <code>printf</code> will interpret that junk value as a pointer and prints out whatever content at that address, yielding the junk output.</li>
</ol>
<p>Note that even though <code>gcc</code> happens to produce the expected output in this case, the undefined behavior is still there (as all C/C++ compilers conform to the same C/C++ Standard), so there is no guarantee that the <code>IsInt64</code> function above will work on <code>gcc</code> or any compiler.</p>
<p>So how to implement this innocent function in a standard-compliant way?</p>
<h3 id="The-Bad-Fix-Attempt-1">The Bad Fix Attempt #1</h3>
<p>To avoid the undefined behavior, we must check that the <code>double</code> fits in the range of the <code>int64_t</code> before doing the casting. However, there’s a few tricky problems involved:</p>
<ol>
<li>While <code>-2^63</code> (the smallest <code>int64_t</code>) has an exact representation in <code>double</code>, <code>2^63-1</code> (the largest <code>int64_t</code>) doesn’t. So we must be careful about the rounding problems when doing the comparison.</li>
<li>Comparing the special floating-point value <code>NaN</code> with any number will yield <code>false</code>, so we must write our check in a way that <code>NaN</code> won’t pass the check.</li>
<li>There is another weird thing called <a href="https://en.wikipedia.org/wiki/Signed_zero" target="_blank" rel="noopener">negative zero</a> (<code>-0</code>). For the purpose of this post, we treat <code>-0</code> same as <code>0</code>. If not, you will need another special check.</li>
</ol>
<p>With these in mind, here’s the updated version:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInt64</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-9223372036854775808.0</span> &lt;= d &amp;&amp; d &lt; <span class="number">9223372036854775808.0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> d == <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(d));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, unfortunately, while the above version is correct, it results in some unnecessarily terrible code on x86-64:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.LCPI0_0:</span><br><span class="line">  .quad   0xc3e0000000000000     # double -9.2233720368547758E+18</span><br><span class="line">.LCPI0_1:</span><br><span class="line">  .quad   0x43e0000000000000     # double 9.2233720368547758E+18</span><br><span class="line">IsInt64(double):                            # @IsInt64(double)</span><br><span class="line">  xor        eax,  eax</span><br><span class="line">  ucomisd    xmm0, qword ptr [rip + .LCPI0_0]</span><br><span class="line">  jb         .LBB0_3</span><br><span class="line">  movsd      xmm1, qword ptr [rip + .LCPI0_1] </span><br><span class="line">  ucomisd    xmm1, xmm0</span><br><span class="line">  jbe        .LBB0_3</span><br><span class="line">  cvttsd2si  rax,  xmm0</span><br><span class="line">  xorps      xmm1, xmm1</span><br><span class="line">  cvtsi2sd   xmm1, rax</span><br><span class="line">  cmpeqsd    xmm1, xmm0</span><br><span class="line">  movq       rax,  xmm1</span><br><span class="line">  and        eax,  1</span><br><span class="line">.LBB0_3:</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>In fact, despite that out-of-range floating-point-to-integer cast is undefined behavior in C/C++, the x86-64 instruction <code>cvttsd2si</code> used above to perform the cast is <a href="https://www.felixcloutier.com/x86/cvttsd2si" target="_blank" rel="noopener">well-defined on all inputs</a>: if the input doesn’t fit in <code>int64_t</code>, then the output is <code>0x80000000 00000000</code>. And since <code>0x80000000 00000000</code> has an exact representation in <code>double</code>, casting it back to <code>double</code> will yield <code>-2^63</code>, which won’t compare equal to any <code>double</code> value but <code>-2^63</code>.</p>
<p>So the range-check is actually unnecessary for the code to behave correctly on x86-64: it is only there to keep the C++ compiler happy, but unfortunately, the C++ compiler is unable to realize that such check is unnecessary on x86-64, thus cannot optimize it out on x86-64.</p>
<p>To summarize, on x86-64, all we need to generate is the last few lines of the above code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IsInt64(double):                           # @IsInt64(double)</span><br><span class="line">  cvttsd2si  rax,  xmm0</span><br><span class="line">  cvtsi2sd   xmm1, rax</span><br><span class="line">  cmpeqsd    xmm1, xmm0</span><br><span class="line">  movq       rax,  xmm1</span><br><span class="line">  and        eax,  1</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>But is there any way we can teach the compiler to generate such assembly?</p>
<h3 id="The-Bad-Fix-Attempt-2">The Bad Fix Attempt #2</h3>
<p>In fact, our original buggy implementation</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInt64</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d == <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>produces <a href="https://godbolt.org/z/66Y4nKc1b" target="_blank" rel="noopener">exactly the above assembly</a>. The problem is, whenever the optimizer of the C++ compiler inlines this function and figures out that the input is a compile-time constant, it will do constant propagation according to C++ rule – and as a result, generate the <code>poison</code> value. So can we stop the optimizer from this unwanted optimization, while still having it doing optimizations properly for the rest of the program?</p>
<p>In fact, I have posted this question on LLVM forum months ago, and didn’t get an answer. But recently I suddenly had an idea. <code>gcc</code> and <code>clang</code> all support a <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html" target="_blank" rel="noopener">crazy builtin</a> named <code>__builtin_constant_p</code>. Basically this builtin takes one parameter, and returns <code>true</code> if the parameter can be proven by the compiler to be a compile-time constant<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. Yes, the result of this function is dependent on the optimization level!</p>
<p>This builtin has a very good use case: to implement <code>constexpr</code> <code>offsetof</code>. If you are certain that some expression <code>p</code> is a compile-time constant, you can do <code>constexpr SomeType foo = __builtin_constant_p(p) ? p : p;</code> to forcefully make <code>p</code> a <code>constexpr</code>, even if <code>p</code> is not <code>constexpr</code> by C++ standard, and the compiler won’t complain anything! This allows one to perform <code>constexpr</code> <code>reinterpret_cast</code> between <code>uintptr_t</code> and pointers, thus implement a <code>constexpr</code>-version <code>offsetof</code> operator.</p>
<p>However, what I realized is that, this builtin can also be used to prevent the unwanted constant propagation. Specifically, we will check <code>if (__builtin_constant_p(d))</code>. If yes, we run the slow-but-correct code – this doesn’t matter as the optimizer is going to constant-fold the code anyway. If not, we execute the fast-but-UB-prone code, which is also fine because we already know the compiler can’t constant-fold anything to trigger the undefined behavior.</p>
<p>The new version of the code is below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DON'T USE IT!</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInt64</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__builtin_constant_p(d)) &#123;</span><br><span class="line">    <span class="comment">// Run UB-free version, knowing that it's going to </span></span><br><span class="line">    <span class="comment">// be constant-folded by the compiler any way</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-9223372036854775808.0</span> &lt;= d &amp;&amp; d &lt; <span class="number">9223372036854775808.0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> d == <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(d));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d == <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(d));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I tried the above code on a bunch of constants and non-constant cases, and the result seems good. Either the input is correctly constant-folded, or the good-version assembly is generated.</p>
<p>So I thought I outsmarted the compiler in this stupid Human-vs-Compiler game. But am I…?</p>
<h3 id="Don’t-Fight-the-Tool">Don’t Fight the Tool!</h3>
<p>Why does C/C++ have this undefined behavior after all? Once I start to think about this problem, I begin to realize that something must be wrong…</p>
<p>The root reason that C/C++ Standard specifies that an out-of-range floating-point-to-integer cast is undefined behavior is because on different architectures, the instruction that performs the float-to-int cast exhibits different behavior when the floating-point value doesn’t fit in the integer type. On x86-64, the behavior of the <code>cvttsd2si</code> instruction in such cases is to produce <code>0x80000000 00000000</code>, which is fine for our use case. But what about the other architectures?</p>
<p>As it turns out, on ARM64, the semantics of the <code>fcvtzs</code> instruction (analogue of x86-64’s <code>cvttsd2si</code>) is saturation: if the floating-point value is larger than the max value of the integer type, the max value is produced; similarly, if the floating-point value is too small, the minimum integer value is produced. So if the <code>double</code> is larger than <code>2^63-1</code>, <code>fcvtzs</code> will produce <code>2^63-1</code>, not <code>-2^63</code> like in x86-64.</p>
<p>Now, recall that <code>2^63-1</code> doesn’t have an exact representation in <code>double</code>. When <code>2^63-1</code> is cast to <code>double</code>, it becomes <code>2^63</code>. So if the input <code>double</code> value is <code>2^63</code>, casting it to <code>int64_t</code> (<code>fcvtzs x8, d0</code>) will yield <code>2^63-1</code>, and then casting it back to <code>double</code> (<code>scvtf d1, x8</code>) will yield <code>2^63</code> again. So on ARM64, our code will determine that the <code>double</code> value <code>2^63</code> fits in <code>int64_t</code>, despite that it actually does not.</p>
<p>I don’t own a ARM64 machine like Apple M1, so I created a virtual machine using <code>QEMU</code> to validate this. Without surprise, on ARM64, our function fails when it is fed the input <code>2^63</code>.</p>
<p>So clearly, the undefined behavior <em>is</em> there for a reason…</p>
<h3 id="Pick-the-Right-Tool-Instead">Pick the Right Tool Instead!</h3>
<p>As it turns out, I really should not have tried to outsmart the compiler with weird tricks. If performance is not a concern, then the UB-free version is actually the only portable and correct version:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInt64</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-9223372036854775808.0</span> &lt;= d &amp;&amp; d &lt; <span class="number">9223372036854775808.0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> d == <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(d));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And if performance <em>is</em> a concern, then it’s better to simply resort to architecture-dependent inline assembly. Yes, now a different implementation is needed for every architecture, but at least it’s better than dealing with hard-to-debug edge case failures.</p>
<p>Of course, the ideal solution is to improve the compiler, so that the portable version generates optimal code on every architecture. But given that neither <code>gcc</code> nor <code>clang</code> had supported this, I assume it’s not an easy thing to do.</p>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Note that this builtin is different from the C++20 <code>std::is_constant_evaluated()</code>. The <code>is_constant_evaluated</code> only concerns whether a <code>constexpr</code> function is being evaluated constexpr-ly. However, <code>__builtin_constant_p</code> tells you whether a (maybe non-constexpr) expression can be deduced to a compile-time known constant under the current optimization level, so it has nothing to do with <code>constexpr</code>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/07/18/2022-07-18/" data-id="cl5u9vg3s000enool238p7gff" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-06-11" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/11/2022-06-11/">Bizarre Performance Characteristics of Alder Lake CPU</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2022/06/11/2022-06-11/" class="article-date"><time datetime="2022-06-11T00:00:00.000Z" itemprop="datePublished">2022-06-11</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>TL;DR: Some of the P-cores in Alder Lake CPU can exhibit highly unstable performance behavior, resulting in large noise for any benchmark running on it.</p>
<p>UPDATE: A colleague of mine reported that the behavior can be observed on his i9-9980HK as well, and observed ~25% end-performance fluctuations on short-running benchmarks. So it seems like this behavior as been around for quite a while – dating back to at least the 9th-gen Intel CPU<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p>
<p>As a performance engineer, it’s routine to evaluate the performance before and after a code commit. This is why I’ve been faintly feeling that something is unusual about my new Intel Alder Lake i7-12700H laptop CPU.</p>
<p>Today I dug into the problem. As I discovered, this CPU indeed exhibits some highly unusual and surprising performance characteristics, which can easily cause pitfalls for benchmarks.</p>
<p>For background, Alder Lake features a <em>hybrid architecture</em> of the powerful P-cores and the weaker E-cores. i7-12700H has 6 P-cores and 8 E-cores. Of course, we want to have the P-cores run our time-sensitive tasks, such as our benchmarks. This can be done easily by <code>taskset</code> the process to only P-cores.</p>
<p>This is where the story begins. I noticed two problems with the P-cores:</p>
<ol>
<li>Sometimes it cannot turbo-boost to 4.7GHz, the <a href="https://ark.intel.com/content/www/us/en/ark/products/132228/intel-core-i712700h-processor-24m-cache-up-to-4-70-ghz.html" target="_blank" rel="noopener">Intel-specified</a> max turbo boost frequency (for the one-active-core case) for i7-12700H.</li>
<li>Sometimes it cannot stay at the highest CPU frequency it can boost to.</li>
</ol>
<p>Point 1 implies that we cannot enjoy the full performance promoted by Intel. Point 2 implies that the core cannot deliver <em>consistent</em> performance, which is problematic for performance engineering, as the noise would make two benchmark runs less comparable.</p>
<h3 id="Test-Setup">Test Setup</h3>
<p>To expose the problem, I wrote a dumb program that increments a variable in a dead loop, so that the frequency of the CPU running the program is maxed out. Then I use <code>taskset</code> to pin the program to one CPU, have it run for 60 seconds, and run <code>cpufreq</code> every second to record the frequency of that CPU in the duration<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p>
<p>I took the following precautions to ensure nothing outside the CPU chip is limiting the CPU from boosting to its max frequency:</p>
<ol>
<li>Use <code>isolcpus</code> Linux kernel boot parameter to exclusively dedicate the tested CPU core to our test program. This removes any noise caused by the OS.</li>
<li>Confirm the CPU is not throttled by power limit: with only one active core (running our test program), the CPU package power consumption is less than <code>25W</code>, far less than the base <code>45W</code> TDP of i7-12700H.</li>
<li>Confirm the CPU is not temperature-throttled (by monitoring sensors). To be paranoid, I also set a <code>20s</code> gap between each test so the temperature goes back to idle state.</li>
<li>Confirm the machine is in idle state, and stop unnecessary background services.</li>
<li>The CPU <a href="https://wiki.archlinux.org/title/CPU_frequency_scaling#Scaling_governors" target="_blank" rel="noopener">frequency governer</a> is set to <code>performance</code>, and I confirmed that the governer is not limiting the turbo boost frequency.</li>
<li>Everything is at stock setting: nothing is overclocked or undervolted, etc.</li>
<li>All tests are repeated 3 times, and consistent behavior is observed for every core.</li>
</ol>
<h3 id="Not-All-P-cores-Are-Born-Equal">Not All P-cores Are Born Equal</h3>
<p>The test confirmed my hypothesis that the 6 P-cores in my i7-12700H do not have a uniform quality. Specifically, my 6 P-cores exhibit three different performance characteriscs!</p>
<p>I dubbed them as “gold core”, “B-grade core”, and “wild core”:</p>
<ol>
<li>Gold core: the core can boost to and stay at 4.7GHz, just as Intel claimed.</li>
<li>B-grade core: the core can boost to and stay at a frequency lower than 4.7GHz.</li>
<li>Wild core: the core cannot boost to 4.7GHz, and cannot stay at any stable frequency: it will fluctuate wildly between a range of frequencies, and the degree of turbulence also varies per core.</li>
</ol>
<p>We will explain their performance characteristics below.</p>
<h3 id="The-“Wild-Cores”">The “Wild Cores”</h3>
<p>Let’s start with the most bizarre cores: the wild ones. As it turns out, 3 out of my 6 P-cores are wild (a whopping 50%!), and among those three cores, one of them is particularly wild, as shown in the plot below<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>:</p>
<p><img src="/images/2022-06-11/P-Core-3.png" alt="x-axis: CPU frequency in GHz, y-axis: time (60 seconds), each line is one run"></p>
<p>As you can see, the CPU frequency turbulents violently from 4.05GHz to 4.55GHz, and each run exhibits a completely different pattern. Clearly, if any benchmark were run on this core, such a large noise would be a headache to deal with.</p>
<p>The other two wild cores I got were less turbulent. Even though, the noise introduced by the frequency instability still make them not ideal for benchmark comparison:</p>
<p><img src="/images/2022-06-11/P-Core-1.png" alt="x-axis: CPU frequency in GHz, y-axis: time (60 seconds), each line is one run"><br>
<img src="/images/2022-06-11/P-Core-5.png" alt="x-axis: CPU frequency in GHz, y-axis: time (60 seconds), each line is one run"></p>
<h3 id="The-“B-grade-Cores”">The “B-grade Cores”</h3>
<p>The B-grade cores (as I dubbed) are better: while they cannot boost to 4.7GHz as promoted by Intel, at least they can operate at a consistent frequency, so benchmark results are comparable as long as they are run on the same core.</p>
<p>It turns out that my i7-12700H has two B-grade cores, both capable of operating at 4.5GHz:</p>
<p><img src="/images/2022-06-11/P-Core-0.png" alt="x-axis: CPU frequency in GHz, y-axis: time (60 seconds), each line is one run"><br>
<img src="/images/2022-06-11/P-Core-4.png" alt="x-axis: CPU frequency in GHz, y-axis: time (60 seconds), each line is one run"></p>
<p>As one can see, the core for the second graph has slightly higher frequency variations. Nevertheless, they are much stabler than the three wild cores.</p>
<h3 id="The-“Gold-Core”">The “Gold Core”</h3>
<p>Only 1 out of the 6 P-cores of my i7-12700H matches Intel’s marketing<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>:</p>
<p><img src="/images/2022-06-11/P-Core-2.png" alt="x-axis: CPU frequency in GHz, y-axis: time (60 seconds), each line is one run"></p>
<p>As one can see, it operates stably at about 4.68GHz, just as Intel claimed.</p>
<h3 id="The-Behavior-of-the-E-cores">The Behavior of the E-cores</h3>
<p>Unlike the P-cores, it turns out that the E-cores have extremely stable behavior. All the eight E-cores can boost to and stay at 3.5GHz, just as the Intel specification said. There is not even a single outlier point: as you can see in the figure, it’s a completely straight line.</p>
<p><img src="/images/2022-06-11/E-Core.png" alt="All E-cores can stay perfectly at 3.5GHz, as they are supposed to"></p>
<h3 id="Conclusion-Thoughts">Conclusion Thoughts</h3>
<p>Given Intel’s tight testing and binning quality-control process, it seems very unlikely that I’m seeing all of these only because I got a defective. So I conjecture the “wild core” behavior can likely be observed on many i7-12700H CPUs.</p>
<p>Additionally, since i7-12700H is just the same i9-12900 chip with two below-quality P-cores disabled, it is also interesting to know if the behavior shows up on higher-end Alder Lake models, like the i9-12900K, as those presumably come from the better silicons, but I don’t have the ability to validate it.</p>
<p>Nevertheless, from a practicalist’s perspective, the action to take is clear: run the benchmark to identify the best cores and the performance-unstable cores on your chip, avoid running benchmarks on the performance-unstable cores, and use the best cores for the most latency-sensitive application.</p>
<p>For example, for my particular chip, physical core 2 (logical core 4-5) turns out to be the only “gold core”, so <code>taskset -c 4</code> for single-threaded benchmark is a good idea. Similarly, for latency-sensitive multi-threaded application (like the <code>QtCreator</code> IDE, where UX is heavily affected by auto-completion latency), it is reasonable to modify the startup command in the desktop link to pin it to the good cores (logical core <code>0,1,4,5,8,9</code> in my particular chip).</p>
<h4 id="But-why">But why?</h4>
<p>I’m not expert at all, but my conjecture is that the increase in clock frequency and # of cores in recent CPUs <em>might</em> be the cause: due to <a href="https://www.makeuseof.com/silicon-lottery-why-no-two-processors-are-the-same/" target="_blank" rel="noopener">silicon lottery</a>, the max stable clock frequency is inherently different for each core. So as the chip gets more cores, it becomes exponentially harder to find chips where <em>all</em> cores in the chip match the spec frequency criteria – so maybe that’s why Intel loosened their criteria?</p>
<p>On the other hand, boost frequency is <em>designed</em> to go down as more cores become active. So in theory, having one golden core is actually enough, as long as the OS is aware of which core is golden, and assigns performance-demanding task to that core. However, it doesn’t seem to be the case yet, at least for my Ubuntu running Linux kernel 5.15.</p>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>On the other hand, my 7-th generation i7-7700HQ CPU does not have the problem described in this post. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>The full bash script for the test can be found <a href="https://sillycross.github.io/assets/2022-06-11/i7_12700h_cpu_test.txt" target="_blank" rel="noopener">here</a>. For least noise, you should use <code>isolcpus</code> boot parameter to isolate a subset of CPUs, reboot, modify the script to only test the isolated subset, then change <code>isolcpus</code> to isolate the opposite set of CPUs, reboot, and modify the script to test the opposite set. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>The two logical CPUs of the physical core exhibit the same behavior, so I only show one of them. Same for other figures in this post. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Though if you take a closer look at their specification, you’ll see what Intel claimed is “up to 4.7GHz”, so technically they did not lie, as they never claimed all cores can meet their specification – though, I guess, two cores 0.2GHz slower, two cores 0.35GHz slower and turbulent, one core 0.5GHz slower and highly turbulent is still, hmm. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/06/11/2022-06-11/" data-id="cl5u9vg3r000dnoold4dsd21z" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-06-02" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/02/2022-06-02/">Understanding GC in JSC From Scratch</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2022/06/02/2022-06-02/" class="article-date"><time datetime="2022-06-02T00:00:00.000Z" itemprop="datePublished">2022-06-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Javascript relies on garbage collection (GC) to reclaim memory. In this post, we will dig a little bit into JSC (the Javascript engine of <a href="https://webkit.org/" target="_blank" rel="noopener">WebKit</a>)'s garbage collection system.</p>
<p>WebKit’s <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/" target="_blank" rel="noopener">blog post on GC</a> is a great post that explained the novelties of JSC’s GC and also positioned it within the context of various GC schemes in academia and industry. However, as someone with little GC background, I found WebKit’s blog post too hard to understand, and also too vague to understand the specific design used by JSC. So this blog post attempts to add in some more details, and aims to be understandable even by someone with little prior background on GC.</p>
<p>The garbage collector in JSC is <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Moving_vs._non-moving" target="_blank" rel="noopener">non-compacting</a>, <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)" target="_blank" rel="noopener">generational</a> and mostly<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>-<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent" target="_blank" rel="noopener">concurrent</a>. On top of being concurrent, JSC’s GC heavily employs lock-free programming for better performance.</p>
<p>As you can imagine, the design used by JSC is quite complex. So instead of diving into the complex invariants and protocols, we will start with the simplest design, and improve it step by step to converge at JSC’s design in the end. This way, we not only understand <em>why</em> JSC’s design works, but also <em>how</em> JSC’s design is reached.</p>
<p>But first of all, let’s get into some background.</p>
<h3 id="Memory-Allocation-in-JSC">Memory Allocation in JSC</h3>
<p>Memory allocator and GC are tightly coupled by nature – the allocator allocates memory to be reclaimed by the GC, and the GC frees memory to be reused by the allocator. In this section, we will briefly introduce JSC’s memory allocators.</p>
<p>At the core of the memory allocation scheme in JSC is the data structure <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectory.h.html#JSC::BlockDirectory" target="_blank" rel="noopener">BlockDirectory</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. It implements a fixed-sized allocator, that is, an allocator that only allocates memory chunks of some fixed size <code>S</code>. The allocator keeps tracks of a list of fixed-sized (in current code, 16KB) memory pages (“blocks”) it owns, and a free list. Each block is divided into cells of size <code>S</code>, and has a footer at its end<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, which contains various metadata information needed for GC and allocator, e.g., which cells are free. By aggregating and sharing metadata at the footer, it both saves memory and improves performance of related operations: we will go into details later.</p>
<p>When a <code>BlockDirectory</code> needs to make an allocation, it tries to allocate from its free list. If the free list is empty, it tries to iterate through the blocks it owns<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, to see if it can find a block containing free cells (which are marked free by GC). If yes, it <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle5sweepEPNS_8FreeListE" target="_blank" rel="noopener">scans the block footer metadata</a> to find out all the free cells<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> in this block, and put into the free list. Otherwise, it allocates a new block from the OS<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Note that this implies a <code>BlockDirectory</code>’s free list only contains cells in one block: this is called <code>m_currentBlock</code> in the code, and we will revisit this later.</p>
<p>The <code>BlockDirectory</code> is used as the building block to build the memory allocators in JSC. JSC employs three kinds of allocators:</p>
<ol>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/CompleteSubspace.h.html#32" target="_blank" rel="noopener">CompleteSubspace</a>: this is a segregated allocator responsible for allocating small objects (max size about 8KB). Specifically, there is a pre-defined list of exponentially-growing size-classes<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>, and one <code>BlockDirectory</code> is used to handle allocation for each size class. So to allocate an object, you find the smallest size class large enough to hold the object, and allocate from that size class.</li>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation" target="_blank" rel="noopener">PreciseAllocation</a>: this is used to handle large allocations that cannot be handled by <code>CompleteSubspace</code> allocator<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>. It simply relies on the standard (malloc-like) memory allocator, though in JSC a custom malloc implementation called <code>libpas</code> is used. The downside is that since <code>PreciseAllocation</code> is done on a per-object basis, it cannot aggregate and share metadata information of multiple objects together to save memory and improve performance (as <code>CompleteSubspace</code>’s block footer did). Therefore, every <code>PreciseAllocation</code> comes with a whopping overhead of a <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation" target="_blank" rel="noopener">96-byte GC header</a> to store the various metadata information needed for GC for this object (though this overhead is justified since each allocation is already at least 8KB).</li>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/IsoSubspace.h.html#JSC::IsoSubspace" target="_blank" rel="noopener">IsoSubspace</a>: each <code>IsoSubspace</code> is used to allocate objects of a fixed type with a fixed size. So each <code>IsoSubspace</code> simply holds a <code>BlockDirectory</code> to do allocation (though JSC also has an optimization for small <code>IsoSubspace</code> by making them backed by <code>PreciseAllocation</code><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>). This is mainly a security hardening feature that makes use-after-free-based attacks harder<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>.</li>
</ol>
<p>As you can see, <code>IsoSubspace</code> is mostly a simplified <code>CompleteSubspace</code>, so we will ignore it for the purpose of this post. <code>CompleteSubspace</code> is the one that handles the common case: small allocations, and <code>PreciseAllocation</code> is mostly the rare slow path for large allocations.</p>
<h3 id="Generational-GC-Basics">Generational GC Basics</h3>
<p>In JSC’s generational GC model, the heap consists of a small “new space” (eden), holding the newly allocated objects, and a large “old space” holding the older objects that have survived one GC cycle. Each GC cycle is either an <em>eden GC</em> or a <em>full GC</em>. New objects are allocated in the eden. When the eden is full, an eden GC is invoked to garbage-collect the unreachable objects in eden. All the surviving objects in eden are then considered to be in the old space<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>. To reclaim objects in the old space, a full GC is needed.</p>
<p>The effectiveness of the above scheme relies on the so-called “generational hypothesis”:</p>
<ol>
<li>Most objects collected by the GC are young objects (died when they are still in eden), so eden GC (which only collects the eden) is sufficient to reclaim most of the memory.</li>
<li>Pointers from old space to eden is much rarer than pointers from eden to old space or pointers from eden to eden, so an eden GC’s runtime is approximately linear to the size of the eden, as it only needs to start from a small subset of the old space. This implies that the cost of GC can be amortized by the cost of allocation.</li>
</ol>
<h4 id="Inlined-vs-Outlined-Metadata-Why">Inlined vs. Outlined Metadata: Why?</h4>
<p>Practically every GC scheme uses some kind of metadata to track which objects are alive. In this section, we will explain how those metadata are stored in JSC, and the motivation behind such design.</p>
<p>In JSC, every object managed by the GC carries the following metadata:</p>
<ol>
<li>Every object managed by GC inherit the <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/runtime/JSCell.h.html#JSC::JSCell" target="_blank" rel="noopener">JSCell</a> class, which contains a 1-byte member <code>cellState</code>. This <code>cellState</code> is a color marker with two colors: white and black<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>.</li>
<li>Every object also has two out-of-object metadata bits: <code>isNew</code><sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup> and <code>isMarked</code>. For objects allocated by <code>PreciseAllocation</code>, the bits reside in the GC header. For objects allocated by <code>CompleteSubspace</code>, the bits reside in the block footer.</li>
</ol>
<p>This may seem odd at first glance since <code>isNew</code> and <code>isMarked</code> could have been stored in the unused bits of <code>cellState</code>. However, this is intentional.</p>
<p>The inlined metadata <code>cellState</code> is easy to access for the mutator thread (the thread executing Javascript code), since it is just a field in the object. However, it has bad memory locality for GC and allocators, which need to quickly traverse through all the metadata of all objects in some block owned by <code>CompleteSubspace</code> (which is the common case). Outlined metadata have the opposite performance characteristics: they are more expensive to access for the mutator thread, but since they are aggregated into bitvectors and stored in the block footer of each block, GC and allocators can traverse them really fast.</p>
<p>So JSC keeps both inlined and outlined metadata to get the better of both worlds: the mutator thread’s fast path will only concern the inlined <code>cellState</code>, while the GC and allocator logic can also take advantage of the memory locality of the outlined bits <code>isNew</code> and <code>isMarked</code>.</p>
<p>Of course, the cost of this is a more complex design… so we have to unfold it bit by bit.</p>
<h3 id="A-Really-Naive-Stop-the-World-Generational-GC">A Really Naive Stop-the-World Generational GC</h3>
<p>Let’s start with a really naive design just to understand what is needed. We will design a generational, but stop-the-world (i.e. not incremental or concurrent) GC, with no performance optimizations at all. In this design, the mutator side transfers control to the GC subsystem at a “safe point”<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> to start a GC cycle (eden or full). The GC subsystem performs the GC cycle from the beginning to the end (as a result, the application cannot run during this potentially long period, thus “stop-the-world”), and then transfer control back to the mutator side.</p>
<p>For this purpose, let’s temporarily forget about <code>CompleteSubspace</code>: it is an optimized version of <code>PrecisionAllocation</code> for small allocations, and while it is an important optimization, it’s easier to understand the GC algorithm without it.</p>
<p>It turns out that in this design, all we need is one <code>isMarked</code> bit. The <code>isMarked</code> bit will indicate if the object is reachable at the end of the last GC cycle (and consequently, is in the old space, since any object that survived a GC cycle is in old space). All objects are born with <code>isMarked = false</code>.</p>
<p>The GC will use a breadth-first search to scan and mark objects. For full GC, we want to reset all <code>isMarked</code> bit to <code>false</code> at the beginnning, and do a BFS to scan and mark all objects reachable from GC roots. Then all the unmarked objects are known to be dead. For eden GC, we only want to scan the eden space. Fortunately, all objects in the old space are already marked at the end of the previous GC cycle, so they are naturally ignored by the BFS, so we can simply reuse the same BFS algorithm in full GC. In pseudo-code:</p>
<p>Eden GC preparation phase: no work is needed.</p>
<p>Full GC preparation phase<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (JSCell* obj : heap) </span><br><span class="line">  obj-&gt;isMarked = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC marking phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">  JSCell* obj = <span class="built_in">queue</span>.pop();</span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      child-&gt;isMarked = <span class="literal">true</span>; </span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC collection phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One can easily imagine optimization to make eden collection </span></span><br><span class="line"><span class="comment">// traverse only the eden space. We ignore it for simplicity.</span></span><br><span class="line"><span class="keyword">for</span> (JSCell* obj : heap) </span><br><span class="line">  <span class="keyword">if</span> (!obj-&gt;isMarked) </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br></pre></td></tr></table></figure>
<p>But where does the scan start, so that we can scan through every reachable object? For full GC, the answer is clear: we just start the scan from all <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Reachability_of_an_object" target="_blank" rel="noopener">GC roots</a><sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>. However, for eden GC, in order to reliably scan through all reachable objects, the situation is slightly more complex:</p>
<ol>
<li>Of course, we still need to push the GC roots to the initial queue.</li>
<li>If an object in the old space contains a pointer to an object in eden, we need to put the old space object to the initial queue<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>.</li>
</ol>
<p>The invariant for the second case is maintained by the mutator side. Specifically, whenever one writes a pointer slot of some object <code>A</code> in the heap to point to another object <code>B</code>, one needs to check if <code>A.isMarked</code> is <code>true</code> and <code>B.isMarked</code> is <code>false</code>. If so, one needs to put <code>A</code> into a “remembered set”. Eden GC must treat the objects in the remembered set as if they were GC roots. This is called a <code>WriteBarrier</code>. In pseudo-code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed after writing a pointer to 'dst' into a field of 'obj'</span></span><br><span class="line"><span class="keyword">if</span> (obj-&gt;isMarked &amp;&amp; !dst-&gt;isMarked) </span><br><span class="line">  addToRememberedSet(obj);</span><br></pre></td></tr></table></figure>
<h3 id="Getting-Incremental">Getting Incremental</h3>
<p>The stop-the-world GC isn’t feasible for production use. A GC cycle (especially a full GC cycle) can take a long time. Since the mutator (application logic) cannot run during the period, the application would appear irresponsive to the user, which is very bad user experience.</p>
<p>A natural way to shorten this irresponsive period is to run GC incrementally: at safe points, the mutator transfers control to the GC. The GC only runs for a short time, doing a portion of the work for the current GC cycle (eden or full), then return control to the mutator. This way, each GC cycle is splitted into many small steps, so the irresponsive periods are less noticeable for the user.</p>
<p>Incremental GC poses a few new challenges to the GC scheme.</p>
<p>The first challenge is the extra interference between GC and mutator: the mutator side, namely the allocator and the <code>WriteBarrier</code>, must be prepared to see states arisen from a partially-completed GC cycle. And the GC side must correctly mark all reachable objects despite changes made by the mutator side in between.</p>
<p>Specifically, our full GC must change: imagine that the full GC scanned some object <code>o</code> and handed back control to mutator, then the mutator changed a field of <code>o</code> to point to some other object <code>dst</code>. The object <code>dst</code> must not be missed from scanning. Fortunately, in such case <code>o</code> will be <code>isMarked</code> and <code>dst</code> will be <code>!isMarked</code> (if <code>dst</code> has <code>isMarked</code> then it has been scanned, so there’s nothing to worry about), so <code>o</code> will be put into the remembered set.</p>
<p>Therefore, for full GC to function correctly in the incremental GC scheme, it must consider the remembered set as GC root as well, just like the eden GC.</p>
<p>The other parts of the algorithm as of now can remain unchanged (we leave the proof of correctness as an excerise for the reader). Nevertheless, “what happens if a GC cycle is run partially?” is something that we must keep in mind as we add more optimizations.</p>
<p>The second challenge is that the mutator side can repeatedly put an old space object into the remembered set, and result in redundant work for the GC: for example, the GC popped some object <code>o</code> in the remembered set, traversed from it, and handed over control to mutator. The mutator modified <code>o</code> again, putting it back to the remembered set. If this happens too often, the incremental GC could do a lot more work than a stop-the-world GC.</p>
<p>The obvious mitigation is to have the GC scan the remembered set last: only when the queue has otherwise been empty do we start popping from the remembered set. However, it turns out that this is not enough. JSC employs a technique called <em>Space-Time Scheduler</em> to further mitigate this problem. In short, if it obverves that the mutator was allocating too fast, the mutator would get decreasingly less time quota to run so the GC can catch up (and in the extreme case, the mutator would get zero time quota to run, so it falls back to the stop-the-world approach). The <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/" target="_blank" rel="noopener">WebKit blog post</a> has explained it very clearly, so feel free to take a look if you are interested.</p>
<p>Anyway, let’s update the pseudo-code for the eden/full GC marking phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty() || !rmbSet.empty()) &#123;</span><br><span class="line">  <span class="comment">// Both eden GC and full GC needs to consider remembered set</span></span><br><span class="line">  <span class="comment">// Prioritize popping from queue, pop remembered set last</span></span><br><span class="line">  JSCell* obj = !<span class="built_in">queue</span>.empty() ? <span class="built_in">queue</span>.pop() : rmbSet.pop();</span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      child-&gt;isMarked = <span class="literal">true</span>; </span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Incorporate-in-CompleteSubspace">Incorporate in CompleteSubspace</h3>
<p>It’s time to get our <code>CompleteSubspace</code> allocator back so we don’t have to suffer the huge per-object GC header overhead incurred by <code>PreciseAllocation</code>.</p>
<p>For <code>PreciseAllocation</code>, the actual memory management work is done by <code>malloc</code>: when the mutator wants to allocate an object, it just <code>malloc</code> it, and when the GC discovers a dead object, it just <code>free</code> it.</p>
<p><code>CompleteSubspace</code> introduces another complexity, as it only allocate/deallocate memory from the OS at 16KB-block level, and does memory management itself to divide the blocks into cells that it serves to the application. Therefore, it has to track whether each of its cells is available for allocation. The mutator allocates from the available cells, and the GC marks dead cells as available for allocation again.</p>
<p>The <code>isMarked</code> bit is not enough for the <code>CompleteSubspace</code> allocator to determine if a cell contains a live object or not: newly allocated objects have <code>isMarked = false</code> but are clearly live objects. Therefore, we need another bit.</p>
<p>In fact, there are other good reasons that we need to support checking if a cell contains a live object or not. A canonical example is the conservative stack scanning: JSC cannot precisely understand the layout of the stack, so it needs to treat everything on the stack that could be pointers and pointing to live objects as GC root, and this involves checking if a heap pointer points to a live object or not.</p>
<p>One can easily imagine some kind of <code>isLive</code> bit that is <code>true</code> for all live objects, which is only flipped to <code>false</code> by GC when the object is dead. However, JSC employed a slightly different scheme, which is needed to facilitate optimizations that we will mention later.</p>
<p>As you have seen earlier, the bit used by JSC is called <code>isNew</code>.</p>
<p><a name="purposeOfIsNewBit"></a>However, keep in mind: you should <strong>not</strong> think of <code>isNew</code> as a bit that tells you <strong>anything</strong> related to its name, or indicates anything by itself. You should think of it as a helper bit, which sole purpose is that, when working togther with <code>isMarked</code>, they tell you if a cell contains a live object or not. This thinking mode will be more important in the next section when we introduce logical versioning.</p>
<p>The core invariant around <code>isNew</code> and <code>isMarked</code> is:</p>
<ol>
<li>At <strong>any</strong> moment, an object is dead iff its <code>isNew = false</code> and <code>isMarked = false</code>.</li>
</ol>
<p>If we were a stop-the-world GC, then to maintain this invariant, we only need the following:</p>
<ol>
<li>When an object is born, it has <code>isNew = true</code> and <code>isMarked = false</code>.</li>
<li>At the end of each eden or full GC cycle, we set <code>isNew</code> of all objects to <code>false</code>.</li>
</ol>
<p>Then, all newly-allocated objects are live because its <code>isNew</code> is <code>true</code>. At the end of each GC cycle, an object is live iff its <code>isMarked</code> is <code>true</code>, so after we set <code>isNew</code> to <code>false</code> (due to rule 2), the invariant on dead object is maintained, as desired.</p>
<p>However, in an incremental GC, since the state of a partially-run GC cycle can be exposed to mutator, we need to be careful that the invariant holds in this case as well.</p>
<p>Specifically, in full GC, we reset all <code>isMarked</code> to <code>false</code> at the beginning. Then, during a partially-run GC cycle, the mutator may see a live object with both <code>isMarked = false</code> (beacuse it has not been marked by GC yet), and <code>isNew = false</code> (because it has survived one prior GC cycle). This violates our invariant.</p>
<p>To fix this, at the beginning of a full GC, we additionally do <code>isNew |= isMarked</code> before clearing <code>isMarked</code>. Now, during the whole full GC cycle, all live objects must have <code>isNew = true</code><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>, so our invariant is maintained. At the end of the cycle, all <code>isNew</code> bits are cleared, and as a result, all the unmarked objects become dead, so our invariant is still maintained as desired. So let’s update our pseudo-code:</p>
<p>Eden GC preparation phase: no work is needed.</p>
<p>Full GC preparation phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do 'isNew |= isMarked, isMarked = false' for all </span></span><br><span class="line"><span class="comment">// PreciseAllocation and all cells in CompleteSubspace</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew |= pa-&gt;isMarked;</span><br><span class="line">  pa-&gt;isMarked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BlockFooter* block : allCompleteSubspaceBlocks) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">    block-&gt;isNew[cellId] |= block-&gt;isMarked[cellId];</span><br><span class="line">    block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC collection phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update 'isNew = false' for CompleteSubspace cells </span></span><br><span class="line"><span class="keyword">for</span> (BlockFooter* block : allCompleteSubspaceBlocks) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">    block-&gt;isNew[cellId] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For PreciseAllocation, in addition to updating 'isNew = false',</span></span><br><span class="line"><span class="comment">// we also need to free the dead objects</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!pa-&gt;isMarked) </span><br><span class="line">    <span class="built_in">free</span>(pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In <code>CompleteSubspace</code> allocator, to check if a cell in a block contains a live object (if not, then the cell is available for allocation):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cellContainsLiveObject</span><span class="params">(BlockFooter* block, <span class="keyword">size_t</span> cellId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> block-&gt;isMarked[cellId] || block-&gt;isNew[cellId];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Logical-Versioning-Do-Not-Sweep">Logical Versioning: Do Not Sweep!</h3>
<p>We are doing a lot of work at the beginning of a full GC cycle and at the end of any GC cycle, since we have to iterate through all the blocks in <code>CompleteSubspace</code> and update their <code>isMarked</code> and <code>isNew</code> bits. Despite that the bits in one block are clustered into bitvectors thus have good memory locality, this could still be an expensive operation, especially after we have a concurrent GC (as this stage cannot be made concurrent). So we want something better.</p>
<p>The optimization JSC employs is logical versioning. Instead of physically clearing all bits in all blocks for every GC cycle, we only bump a global “logical version”, indicating that all the bits are logically cleared (or updated). Only when we actually need to mark a cell in a block during the marking phase do we then physically clear (or update) the bitvectors in this block.</p>
<p>You may ask: why bother with logical versioning, if in the future we still have to update the bitvectors physically anyway? There are two good reasons:</p>
<ol>
<li>If all cells in a block are dead (either died out during this GC cycle<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>, or already dead before this GC cycle), then we will never mark anything in the block, so logical versioning enabled us to avoid the work altogether. This also implies that at the end of each GC cycle, it’s unnecessary to figure out which blocks become completely empty, as logical versioning makes sure that these empty blocks will not cause overhead to future GC cycles.</li>
<li>The marking phase can be done concurrently with multiple threads <em>and</em> while the mutator thread is running (our scheme isn’t concurrent now, but we will do it soon), while the preparation / collection phase must be performed single-threadedly <em>and</em> with the mutator stopped. Therefore, shifting the work to marking phase reduces GC latency in a concurrent setting.</li>
</ol>
<p>There are two global version number <code>g_markVersion</code> and <code>g_newVersion</code><sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>. Each block footer also stores its local version number <code>l_markVersion</code> and <code>l_newVersion</code>.</p>
<p>Let’s start with the easier case: the logical versioning for the <code>isNew</code> bit.</p>
<p>If you revisit the pseudo-code above, in GC there is only one place where we write <code>isNew</code>: at the end of each GC cycle, we set all the <code>isNew</code> bits to <code>false</code>. Therefore, we simply <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedSpace.cpp.html#446" target="_blank" rel="noopener">bump</a> <code>g_newVersion</code> there instead. A local version <code>l_newVersion</code> smaller than <code>g_newVersion</code> means that all the <code>isNew</code> bits in this block have been logically cleared to <code>false</code>.</p>
<p>When the <code>CompleteSubspace</code> allocator allocates a new object, it needs to start with <code>isNew = true</code>. One can clearly do this directly, but JSC did it in a trickier way that involves a block-level bit named <code>allocated</code> for slightly better performance. This is not too interesting, so I deferred it to <a href="#isNewAndAllocateBit">the end of the post</a>, and our scheme described here right now will not employ this optimization (but is otherwise intentionally kept semantically equivalent as JSC):</p>
<ol>
<li>When a <code>BlockDirectory</code> starts allocating from a new block, it update the the block’s <code>l_newVersion</code> to <code>g_newVersion</code>, and set <code>isNew</code> to <code>true</code> for all already-allocated cells (as the block may not be fully empty), and <code>false</code> for all available cells.</li>
<li>Whenever it allocates a cell, it sets its <code>isNew</code> to true.</li>
</ol>
<p>Why do we want to bother setting <code>isNew</code> to <code>true</code> for all already-allocated cells in the block? This is to provide a good property. Since we bump <code>g_newVersion</code> at the end of every GC cycle, due to the scheme above, for any block with latest <code>l_newVersion</code>, a cell is live if and only if its <code>isNew</code> bit is set. Now, when checking if a cell is live, if its <code>l_newVersion</code> is latest, then we can just return <code>isNew</code> without looking at <code>isMarked</code>, so our logic is simpler.</p>
<p>The logical versioning for the <code>isMarked</code> bit is similar. At the beginning of a full GC cycle, we bump the <code>g_markVersion</code> to indicate that all mark bits are logically cleared. Note that the global version is not bumped for eden GC, since eden GC does not clear <code>isMark</code> bits.</p>
<p>There is one extra complexity: the above scheme would break down in incremental GC. Specifically, <em>during</em> a full GC cycle, we have logically cleared the <code>isMarked</code> bit, but we also didn’t do anything to the <code>isNew</code> bit, so all cells in the old space would appear dead to the allocator. In our old scheme without logical versioning, this case is prevented by doing <code>isNew |= isMarked</code> at the start of the full GC, but we cannot do it now with logical versioning.</p>
<p>JSC solves this problem with the following clever trick: <em>during</em> a full GC, we should also accept <code>l_markVersion</code> that is off-by-one. In that case, we know the <code>isMarked</code> bit accurately reflect whether or not a cell is live, since that is the result of the last GC cycle. If you are a bit confused, take a look at footnote<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup> for a more elaborated case discussion. It might also help to take a look at the comments in the pseudo-code below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cellContainsLiveObject</span><span class="params">(BlockFooter* block, <span class="keyword">size_t</span> cellId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (block-&gt;l_newVersion == g_newVersion) &#123;</span><br><span class="line">    <span class="comment">// A latest l_newVersion indicates that the cell is live if</span></span><br><span class="line">    <span class="comment">// and only if its 'isNew' bit is set, so we don't need to</span></span><br><span class="line">    <span class="comment">// look at the 'isMarked' bit even if 'isNew' is false</span></span><br><span class="line">    <span class="keyword">return</span> block-&gt;isNew[cellId];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Now we know isNew bit is logically false, so we should</span></span><br><span class="line">  <span class="comment">// look at the isMarked bit to determine if the object is live</span></span><br><span class="line">  <span class="keyword">if</span> (isMarkBitLogicallyCleared(block)) &#123;</span><br><span class="line">    <span class="comment">// The isMarked bit is logically false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// The isMarked bit is valid and accurately tells us if </span></span><br><span class="line">  <span class="comment">// the object is live or not</span></span><br><span class="line">  <span class="keyword">return</span> block-&gt;isMarked[cellId];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if the isMarked bitvector is logically cleared</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMarkBitLogicallyCleared</span><span class="params">(BlockFooter* block)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (block-&gt;l_markVersion == g_markVersion) &#123;</span><br><span class="line">    <span class="comment">// The mark version is up-to-date, so not cleared</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IsFullGcRunning() &amp;&amp; IsGcInMarkingPhase() &amp;&amp; </span><br><span class="line">      block-&gt;l_markVersion == g_markVersion - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// We are halfway inside a full GC cycle's marking phase,</span></span><br><span class="line">    <span class="comment">// and the mark version is off-by-one, so the isMarked bit</span></span><br><span class="line">    <span class="comment">// should be accepted, and it accurately tells us if the </span></span><br><span class="line">    <span class="comment">// object is live or not</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Before we mark an object in <code>CompleteSubspace</code>, we need to update the <code>l_markVersion</code> of the block holding the cell to latest, and materialize the <code>isMarked</code> bits of all cells in the block. That is, we need to run the logic at the full GC preparation phase in our old scheme: <code>isNew |= isMarked</code>, <code>isMarked = false</code> for all cells in the block. This is shown below.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Used by GC marking phase to mark an object in CompleteSubspace</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markObject</span><span class="params">(BlockFooter* block, <span class="keyword">size_t</span> cellId)</span> </span>&#123;</span><br><span class="line">  aboutToMark(block);</span><br><span class="line">  block-&gt;isMarked[cellId] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Materialize 'isMarked' bits if needed</span></span><br><span class="line"><span class="comment">// To do this, we need to execute the operation at full GC </span></span><br><span class="line"><span class="comment">// prepare phase: isNew |= isMarked, isMarked = false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aboutToMark</span><span class="params">(BlockFooter* block)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (block-&gt;l_markVersion == g_markVersion) &#123;</span><br><span class="line">    <span class="comment">// Our mark version is already up-to-date,</span></span><br><span class="line">    <span class="comment">// which means it has been materialized before</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check if the isMarked bit is logically cleared to false.</span></span><br><span class="line">  <span class="comment">// The function is defined in the previous snippet.</span></span><br><span class="line">  <span class="keyword">if</span> (isMarkBitLogicallyCleared(block)) &#123;</span><br><span class="line">    <span class="comment">// This means that the isMarked bitvector should </span></span><br><span class="line">    <span class="comment">// be treated as all false. So operation isNew |= isMarked </span></span><br><span class="line">    <span class="comment">// is no-op, so all we need to do is isMarked = false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">      block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The 'isMarked' bit is not logically cleared. Now let's </span></span><br><span class="line">    <span class="comment">// check if the 'isNew' bit is logically cleared.</span></span><br><span class="line">    <span class="keyword">if</span> (block-&gt;l_newVersion &lt; g_newVersion) &#123;</span><br><span class="line">      <span class="comment">// The isNew bitvector is logically cleared and should be </span></span><br><span class="line">      <span class="comment">// treated as false. So operation isNew |= isMarked becomes</span></span><br><span class="line">      <span class="comment">// isNew = isMarked (note that executing |= is incorrect </span></span><br><span class="line">      <span class="comment">// beacuse isNew could physically contain true!)</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">        block-&gt;isNew[cellId] = block-&gt;isMarked[cellId];</span><br><span class="line">        block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// We materialized isNew, so update it to latest version</span></span><br><span class="line">      block-&gt;l_newVersion = g_newVersion;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// The l_newVersion is latest, which means that the cell is </span></span><br><span class="line">      <span class="comment">// live if and only if its isNew bit is set. </span></span><br><span class="line">      <span class="comment">// Since isNew already reflects liveness, we do not have to</span></span><br><span class="line">      <span class="comment">// perform the operation isNew |= isMarked (and in fact, it </span></span><br><span class="line">      <span class="comment">// must be a no-op since no dead cell can have isMarked = </span></span><br><span class="line">      <span class="comment">// true). So we only need to do isMarked = false</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">        block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We finished materializing isMarked, so update the version</span></span><br><span class="line">  block-&gt;l_markVersion = g_markVersion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A fun fact: despite that what we conceptually want to do above is <code>isNew |= isMarked</code>, the above code never performs a <code>|=</code> at all :)</p>
<p>And also, let’s update the pseudo-code for relavent GC logic:</p>
<p>Eden GC preparation phase: no work is needed.</p>
<p>Full GC preparation phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For PreciseAllocation, we still need to manually do </span></span><br><span class="line"><span class="comment">// 'isNew |= isMarked, isMarked = false' for every allocation</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew |= pa-&gt;isMarked;</span><br><span class="line">  pa-&gt;isMarked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For CompleteSubspace, all we need to do is bumping the </span></span><br><span class="line"><span class="comment">// global version for 'isMarked' bit</span></span><br><span class="line">g_markVersion++;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC collection phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For PreciseAllocation, we still need to manually </span></span><br><span class="line"><span class="comment">// update 'isNew = false' for each allocation, and also</span></span><br><span class="line"><span class="comment">// free the object if it is dead</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!pa-&gt;isMarked) </span><br><span class="line">    <span class="built_in">free</span>(pa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For CompleteSubspace, all we need to do is bumping the</span></span><br><span class="line"><span class="comment">// global version for 'isNew' bit</span></span><br><span class="line">g_newVersion++;</span><br></pre></td></tr></table></figure>
<p>With logical versioning, GC no longer sweeps the <code>CompleteSubspace</code> blocks to reclaim dead objects: the reclamation happens lazily, when the allocator starts to allocate from the block. This, however, introduces an unwanted side-effect. Some objects use manual memory management internally: they own additional memory that are not managed by GC, and have C++ destructors to free those memory when the object is dead. This improves performance as it reduces the work of GC. However, now we do not immediately sweep dead objects and run destructor, so the memory that are supposed to be freed by the destructor could be kept around indefinitely longer, if the block is never allocated from. To mitigate this issue, JSC will also periodically sweep the blocks and run the destructors of the dead objects. This is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/IncrementalSweeper.h.html#JSC::IncrementalSweeper" target="_blank" rel="noopener">implemented</a> by <code>IncrementalSweeper</code>, but we will not go into details.</p>
<p>To conclude, logical versioning provided two important optimizations to the GC scheme:</p>
<ol>
<li>The so-called “sweep” phase of the GC (to find out and reclaim dead objects) is removed for <code>CompleteSubspace</code> objects. The reclamation is done lazily. This is clearly better than sweeping through the block again and again in every GC cycle.</li>
<li>The full GC does not need to reset all <code>isMarked</code> bit in the preparation phase, but only lazily reset them in the marking phase by <code>aboutToMark</code>: this not only reduces work, but also allows the work to be done parallelized and while the mutator is running, after we make our GC scheme concurrent.</li>
</ol>
<h3 id="Optimizing-WriteBarrier-The-cellState-Bit">Optimizing WriteBarrier: The cellState Bit</h3>
<p>As we have explained earlier, whenever the mutator modified a pointer of a marked object <code>o</code> to point to an unmarked object, it needs to add <code>o</code> to the “remembered set”, and this is called the <code>WriteBarrier</code>. In this section, we will dig a bit deeper into the <code>WriteBarrier</code> and explain the optimizations around it.</p>
<p>The first problem with our current <code>WriteBarrier</code> is that the <code>isMarked</code> bit resides in the block footer, so retrieving its value requires quite a few computations from the object pointer. Also it doesn’t sit in the same CPU cache line as the object, which makes the access even slower. This is undesirable as the cost is paid for every <code>WriteBarrier</code>, no matter if we actually added the object to remembered set in the end or not.</p>
<p>The second problem is, our <code>WriteBarrier</code> will repeatedly add the same object <code>o</code> to the remembered set every time it is run. The obvious solution is to make <code>rememberedSet</code> a hash set to de-duplicate the objects it contains, but doing a hash lookup to check if the object already exists is still too expensive.</p>
<p>This is where the last metadata bit that we haven’t explained yet: the <code>cellState</code> bit comes in, which solves both problems.</p>
<p>Instead of making <code>rememberedSet</code> a hash table, we reserve a byte (though we only use 1 bit of it) named <code>cellState</code> in every object’s object header, to indicate if we might need to put the object into the remembered set in a <code>WriteBarrier</code>. Since this bit resides in the object header as an object field (instead of in the block footer), it’s trivially accessible to the mutator who has the object pointer.</p>
<p><code>cellState</code> has two possible values: <code>black</code> and <code>white</code>. The most important two invariants around <code>cellState</code> are the following:</p>
<ol>
<li>For any object with <code>cellState = white</code>, it is guaranteed that the object does not need to be added to remembered set.</li>
<li>Unless <em>during</em> a full GC cycle, all <code>black</code> (live) objects have <code>isMarked = true</code>.</li>
</ol>
<p>Invariant 1 serves as a fast-path: <code>WriteBarrier</code> can return immediately if our object is <code>white</code>, and checking it only requires one load instruction (to load <code>cellState</code>) and one comparison instruction to validate it is <code>white</code>.</p>
<p>However, if the object is <code>black</code>, a slow-path is needed to check whether it is actually needed to add the object to remembered set.</p>
<p>Let’s look at our new <code>WriteBarrier</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed after writing a pointer to 'dst' into a field of 'obj'</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrier</span><span class="params">(JSCell* obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj-&gt;cellState == black) </span><br><span class="line">    WriteBarrierSlowPath(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first thing to notice is that the <code>WriteBarrier</code> is no longer checking if <code>dst</code> (the object that the pointer points to) is marked or not. Clearly this does not affect the correctness: we are just making the criteria less restrictive. However, it is unclear to me if we can improve performance while maintaining correctness by making some kind of check on <code>dst</code> as well, like the original <code>WriteBarrier</code> did.</p>
<p>I wasn’t able to get a definite answer on this even from JSC developer. They have two <em>conjectures</em> on why they are doing this: first, by not checking <code>dst</code>, more objects are put into the remembered set and need to be scanned by GC, so the total amount of work increased. However, the mutator’s work probably decreased, as it does less checks and touches less cache lines (by not touching the outlined <code>isMarked</code> bit). Of course, the benefit is offsetted by that the mutator is adding more objects into the remembered set, but this isn’t too expensive either, as the remembered set is only a segmented vector. GC has to do more work, as it needs to scan and mark more objects. However, after we make our scheme concurrent, the marking phase of GC can be done concurrently as the mutator is running, so the latency is probably<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup> hidden. Second, JSC’s DFG compiler has <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGStoreBarrierInsertionPhase.cpp.html" target="_blank" rel="noopener">optimization pass</a> that coalesces barriers on the same object together, and the barrier emitted this way naturally cannot check <code>dst</code>. Therefore, to make things easier, they simply made all the barriers to not check <code>dst</code>. Although these are all conjectures, and it is unclear if adding back the <code>dst</code> check can improve performance, this is how JSC works, so let’s stick to it.</p>
<p>The interesting part is how the invariants above are maintained by the relavent parties. As always, there are three actors: the mutator (<code>WriteBarrier</code>), the allocator, and the GC.</p>
<p>The interaction with the allocator is the simplest. All objects are born <code>white</code>. This is correct because newly-born objects are not marked, so have no reason to be remembered.</p>
<p>The interaction with GC is during the GC marking phase:</p>
<ol>
<li>When we mark an object and push it into the queue, we set its <code>cellState</code> to <code>white</code>.</li>
<li>When we pop an object from the queue, before we start to scan its children, we set its <code>cellState</code> to <code>black</code>.</li>
</ol>
<p>In pseudo-code, the Eden/Full GC marking phase now looks like the following (Line 5 and Line 9 are the newly-added logic to handle <code>cellState</code>, other lines unchanged):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty() || !rmbSet.empty()) &#123;</span><br><span class="line">  <span class="comment">// Both eden GC and full GC needs to consider remembered set</span></span><br><span class="line">  <span class="comment">// Prioritize popping from queue, pop remembered set last</span></span><br><span class="line">  JSCell* obj = !<span class="built_in">queue</span>.empty() ? <span class="built_in">queue</span>.pop() : rmbSet.pop();</span><br><span class="line">  obj-&gt;cellState = black;       <span class="comment">// &lt;----------------- newly added</span></span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      markObject(child);</span><br><span class="line">      child-&gt;cellState = white; <span class="comment">// &lt;----------------- newly added</span></span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s argue why the invariant is maintained by the above code.</p>
<ol>
<li>For invariant 1, note that in the above code, an object is <code>white</code> only if it is inside the queue (as once it’s popped out, it becomes <code>black</code> again), pending scanning of its children. Therefore, it is guaranteed that the object will still be scanned by the GC later, so we don’t need to add the object to remembered set, as desired.</li>
<li>For invariant 2, at the end of any GC cycle, any live object is marked, which means it has been scanned, so it is <code>black</code>, as desired.</li>
</ol>
<p>Now let’s look at what <code>WriteBarrierSlowPath</code> should do. Clearly, it’s correct if it simply unconditionally add the object to remembered set, but that also defeats most of the purpose of <code>cellState</code> as an optimization mechanism: we want something better.</p>
<p>A top business of <code>cellState</code> is to prevent adding an object into the remembered set if it is already there. Therefore, after we put the object into the remembered set, we will set its <code>cellState</code> to <code>white</code>, like shown below.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrierSlowPath</span><span class="params">(JSCell* obj)</span> </span>&#123; </span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  addToRememberedSet(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s prove why the above code works. Once we added an object to remembered set, we set it to <code>white</code>. We don’t need to add the same object into the remembered set until it gets popped out from the set by GC. But when GC pops out the object, it would set its <code>cellState</code> back to <code>black</code>, so we are good.</p>
<p>JSC employed one more optimization. During a full GC, we might see <code>black</code> objects that has <code>isMarked = false</code> (note that this is the only possible case that the object is unmarked, due to invariant 2). In this case, it’s unnecessary to add the object to remembered set, since the object will eventually be scanned in the future (or it becomes dead some time later before it was scanned, in which case we are good as well). Furthermore, we can flip it back to <code>white</code>, so we don’t have to go into this slow path the next time a <code>WriteBarrier</code> on this object runs. To sum up, the optimized version is as below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrierSlowPath</span><span class="params">(JSCell* obj)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (IsFullGcRunning()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMarked(obj)) &#123;</span><br><span class="line">      <span class="comment">// Do not add the object to remembered set</span></span><br><span class="line">      <span class="comment">// In addition, set cellState to white so this </span></span><br><span class="line">      <span class="comment">// slow path is not triggered on the next run</span></span><br><span class="line">      obj-&gt;cellState = white;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(isMarked(obj));    <span class="comment">// due to invariant 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  addToRememberedSet(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Getting-Concurrent-and-Getting-Wild">Getting Concurrent and Getting Wild</h3>
<p>At this point, we already have a very good incremental and generational garbage collector: the mutator, allocator and GC all have their respective fast-paths for the common cases, and with logical versioning, we avoided redundant work as much as possible. In my humble opinion, this is a good balance point between performance and engineering complexity.</p>
<p>However, obviously, “engineering complexity” is not a word inside JSC’s dictionary: after all, they have the most talented engineers, to the point that they even <a href="https://webkit.org/blog/5852/introducing-the-b3-jit-compiler/" target="_blank" rel="noopener">engineered their own purpose-built LLVM from scratch</a>!</p>
<p>To squeeze out every bit of performance, JSC proceeded to make the GC scheme concurrent. However, due to the nature of GC, it’s often infeasible to use locks to protect against race conditions for performance reasons, so extensive lock-free programming is employed.</p>
<p>But once lock-free programming is involved, one starts to get into all sorts of architecture-dependent memory reordering problems. x86-64 is the more sane architecture: it only requires <code>StoreLoadFence()</code>, and it provides somewhat-TSO-like semantics, but JSC also needs ARM64 support for their Apple Sillicon devices. ARM64 has even fewer guarantees: load-load, load-store, store-load, and store-store can all be reordered by the CPU, so any innocent operation could actually need a fence. As if things were not bad enough, for performance reasons, JSC does not want to use too many memory fences on ARM64. So they have the so-called <code>Dependency</code> <a href="https://sillycross.github.io/r/WebKit/Source/WTF/wtf/Atomics.h.html#_ZN3WTF10DependencyC1Ev" target="_blank" rel="noopener">class</a>, which creates an implicit CPU data dependency on ARM64 through some scary assembly hacks, so they can get the desired memory ordering for a specific data-flow without paying the cost of a memory fence. As you can imagine, with all of these complications and optimizations, the code can easily become horrifying.</p>
<p>So due to my limited expertise, it’s unsurprising if I missed to explain or mis-explained some important race conditions in the code, especially some ARM64-specific ones: if you spotted any issue in this post, please definitely let me know.</p>
<p>Let’s go through the concurrency assumptions first. Javascript is a single-threaded language, so there is always only one mutator thread<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>. Apart from the mutator thread, JSC has a bunch of compilation threads, a GC thread, and a bunch of marking threads. Only the GC marking phase is concurrent: during which the mutator thread, the compiler threads, and a bunch of marking threads are concurrently running (yes, the marking itself is also done in parallel). However, all the other GC phases are run with the mutator thread and compilation threads stopped.</p>
<h4 id="Some-Less-Interesting-Issues">Some Less Interesting Issues</h4>
<p>First of all, clearly the <code>isMarked</code> and <code>isNew</code> bitvector must be made safe for concurrent access, since multiple threads (including marking threads and mutator) may concurrently update it. Using CAS with appropriate retry/bail mechanism is enough for the bitvector itself.</p>
<p><code>BlockFooter</code> is harder, and needs to be protected with a lock: multiple threads could be simutanuously calling <code>aboutToMark()</code>, so <code>aboutToMark()</code> must be guarded. For the reader side (the <code>isMarked()</code> function, which involves first checking if <code>l_markVersion</code> is latest, then reading the <code>isMarked</code> bitvector), in x86-64 thanks to x86-TSO, one does not need a lock or any memory fence (as long as <code>aboutToMark</code> takes care to update <code>l_markVersion</code> after the bitvector). In ARM64, since load-load reordering is allowed, a <code>Dependency</code> is required.</p>
<p>Making the <code>cellContainsLiveObject</code> (or in JSC jargon, <code>isLive</code>) check lock-free is harder, since it involves potentially reading both the <code>isMarked</code> bit and the <code>isNew</code> bit. JSC <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlockInlines.h.html#_ZN3JSC11MarkedBlock6Handle6isLiveEjjbPKNS_8HeapCellE" target="_blank" rel="noopener">employs optimistic locking</a> to provide a fast-path. This is not very different from an optimistic locking scheme you can find in a textbook, so I won’t dive into the details.</p>
<p>Of course, there are a lot more subtle issues to change. Almost all the pseudo-code above needs to be adapted for concurrency, either by using a lock or CAS, or by using some sort of memory barriers and concurrency protocol to ensure that the code works correctly under concurrency settings. But now let’s turn to some more important and tricky issues.</p>
<h4 id="The-Race-Between-WriteBarrier-and-Marking">The Race Between WriteBarrier and Marking</h4>
<p>One of the most important race is the race between <code>WriteBarrier</code> and GC’s marking threads. The marking threads and the mutator thread can access the <code>cellState</code> of an object concurrently. For performance reasons, a lock is infeasible, so race condition arises.</p>
<p>It’s important to note that we call <code>WriteBarrier</code> <strong>after</strong> we have written the pointer into the object. This is not only more convenient to use (especially for JIT-generated code), but also allows a few optimizations: for example, <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGStoreBarrierInsertionPhase.cpp.html" target="_blank" rel="noopener">in certain cases</a>, multiple writes to the same object may only call <code>WriteBarrier</code> once at the end.</p>
<p>With this in mind, let’s analyze why our current implementation is buggy. Suppose <code>o</code> is an object, and the mutator wants to store a pointer to another object <code>target</code> into a field <code>f</code> of <code>o</code>. The marking logic of GC wants to scan <code>o</code> and append its children into the queue. We need to make sure that GC will observe the <code>o -&gt; target</code> pointer link.</p>
<p>Let’s first look at the correct logic:</p>
<div>
<div style="float:left; width:50%; border-right: solid 1px; border-bottom: solid 1px; background-color:#FFCB9A">
<div style="margin-left:10px; ">
Mutator (WriteBarrier)
</div>
</div>
<div style="float:left; width:50%; border-bottom: solid 1px; background-color:#A8B545">
<div style="margin-left:10px;">
GC (Marker) 
</div>
</div>
</div>
<div>
<div style="float:left; width:50%; border-right: solid 1px;">
<div style="margin-left:10px; ">
Store(o.f, target)<br>
StoreLoadFence()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// WriteBarrier begin<br>                               
t1 = Load(o.cellState)<br>
if (t1 == black): WriteBarrierSlowPath(o)
</div>
</div>
<div style="float:left; width:50%;">
<div style="margin-left:10px;">
Store(o.cellState, black)<br>
StoreLoadFence()<br>
t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load a children of o<br>
Do some check to t2 and push it to queue<br>
</div>
</div>
</div>
<div style="display: table; clear: both;"</div>
<br>
<p>This is mostly just a copy of the pseudocode in the above sections, except that we have two <code>StoreLoadFence()</code>. A <code>StoreLoadFence()</code> guarantees that no <code>LOAD</code> after the fence may be executed by the CPU out-of-order engine until all <code>STORE</code> before the fence have completed. Let’s first analyze what could go wrong without either of the fences.</p>
<p>Just to make things perfectly clear, the precondition is <code>o.cellState = white</code> (because <code>o</code> is in the GC’s queue) and <code>o.f = someOldValue</code>.</p>
<p>What could go wrong if the mutator <code>WriteBarrier</code> doesn’t have the fence? Without the fence, the CPU can execute the <code>LOAD</code> in line 3 before the <code>STORE</code> in line 1. Then, in the following interleaving:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = white</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
</ol>
<p>Now, the mutator did not add <code>o</code> to remembered set (because <code>t1</code> is <code>white</code>, not <code>black</code>), and <code>t2</code> in GC is the old value in <code>o.f</code> instead of <code>target</code>, so GC did not push <code>target</code> into the queue. So the pointer link from <code>o</code> to <code>target</code> is missed in GC. This can result in <code>target</code> being wrongly reclaimed despite it is live.</p>
<p>And what could go wrong if the GC marking logic doesn’t have the fence? Similarly, without the fence, the CPU can execute the <code>LOAD</code> in line 3 before the <code>STORE</code> in line 1. Then, in the following interleaving:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = white</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
</ol>
<p>Similar to above, mutator sees <code>t1 = white</code> and GC sees <code>t2 = oldValue</code>. So <code>o</code> is not added to remembered set, and <code>target</code> is not pushed into the queue, the pointer link is missed.</p>
<p>Finally, let’s analyze why the code behaves correctly if both fences are present. Unfortunately there is not a better way than manually enumerating all the interleavings. Thanks to the fences, <code>Mutator Line 1</code> must execute before <code>Mutator Line 3</code>, and <code>GC Line 1</code> must execute before <code>GC Line 3</code>, but the four lines can otherwise be reordered arbitrarily. So there are <code>4! / 2! / 2! = 6</code> possible interleavings. So let’s go!</p>
<p>Interleaving 1:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = white</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>In this interleaving, the mutator did not add <code>o</code> to remembered set, but the GC sees <code>target</code>, so it’s fine.</p>
<p>Interleaving 2:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
</ol>
<p>In this interleaving, GC saw the old value, but the mutator added <code>o</code> to the remembered set, so GC will eventually drain from the remembered set and scan <code>o</code> again, at which time it will see the correct new value <code>target</code>, so it’s fine.</p>
<p>Interleaving 3:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>In this interleaving, GC saw the new value <code>target</code>, nevertheless, the mutator saw <code>t1 = black</code> and added <code>o</code> to the remembered set. This is unfortunate since GC will scan <code>o</code> again, but it doesn’t affect correctness.</p>
<p>Interleaving 4:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>Interleaving 5:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>Interleaving 6:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>This proves that with the two <code>StoreLoadFence()</code>, our code is no longer vulnerable to the above race condition.</p>
<h4 id="Another-Race-Condition-Between-WriteBarrier-and-Marking">Another Race Condition Between WriteBarrier and Marking</h4>
<p>The above fix alone is not enough: there is another race between <code>WriteBarrier</code> and GC marking threads. Recall that in <code>WriteBarrierSlowPath</code>, we attempt to flip the object back to <code>white</code> if we saw it is not marked (this may happen during a full GC), as illustrated below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">... omitted ...</span><br><span class="line"><span class="keyword">if</span> (!isMarked(obj)) &#123;</span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">... omitted ...</span><br></pre></td></tr></table></figure>
<p>It turns out that, after setting the object <code>white</code>, we need to do a <code>StoreLoadFence()</code>, and check again if the object is marked. If it becomes marked, we need to set <code>obj-&gt;cellState</code> back to <code>black</code>.</p>
<p>Without the fix, the code is vulnerable to the following race:</p>
<ol>
<li>[Precondition] <code>o.cellState = black</code> and <code>o.isMarked = false</code></li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Check isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see false</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>[Postcondition] <code>o.cellState = white</code> and <code>o.isMarked = true</code></li>
</ol>
<p>The post-condition is bad because <code>o</code> will not be added to the remembered set in the future, despite that it needs to be (as the GC has already scanned it).</p>
<p>Let’s now prove why the code is correct when the fix is applied. Now the <code>WriteBarrier</code> logic looks like this:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)</div>
</li>
</ol>
<p>Note that we omitted the first “Check isMarked()” line because it must be the first thing executed in the interleaving, as otherwise the <code>if</code>-check won’t pass at all.</p>
<p>The three lines in <code>WriteBarrier</code> cannot be reordered by CPU: Line 1-2 cannot be reordered because of the <code>StoreLoadFence()</code>, line 2-3 cannot be reordered since line 3 is a store that is only executed if line 2 is true. The two lines in GC cannot be reordered by CPU because line 2 stores to the same field <code>o.cellState</code> as line 1.</p>
<p>In addition, note that it’s fine if at the end of <code>WriteBarrier</code>, the object is <code>black</code> but GC has only executed to line 1: this is unfortunate, because the next <code>WriteBarrier</code> on this object will add the object to the remembered set despite it’s unnecessary. However, it does not affect our correctness. So now, let’s enumerate all the interleavings again!</p>
<p>Interleaving 1.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = false</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// not executed</div>
</li>
</ol>
<p>Object is not marked and white, OK.</p>
<p>Interleaving 2.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = false</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// not executed</div>
</li>
</ol>
<p>Object is in queue and white, OK.</p>
<p>Interleaving 3.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is in queue and black, unfortunate but OK.</p>
<p>Interleaving 4.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is in queue and black, unfortunate but OK.</p>
<p>Interleaving 5.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = false</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// not executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 6.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 7.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 8.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 9.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 10.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>So let’s update our pseudo-code. However, I would like to note that, in JSC’s implementation, they did not use a <code>StoreLoadFence()</code> after <code>obj-&gt;cellState = white</code>. Instead, they made the <code>obj-&gt;cellState = white</code> a CAS from <code>black</code> to <code>white</code> (with memory ordering <code>memory_order_seq_cst</code>). This is stronger than a <code>StoreLoadFence()</code> so their logic is also correct. Nevertheless, just in case my analysis above missed some other race with other components, our pseudo-code will stick to their logic…</p>
<p>Mutator <code>WriteBarrier</code> pseudo-code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrier</span><span class="params">(JSCell* obj)</span> </span>&#123;</span><br><span class="line">  StoreLoadFence();            <span class="comment">// Note the fence!</span></span><br><span class="line">  <span class="keyword">if</span> (obj-&gt;cellState == black) </span><br><span class="line">    WriteBarrierSlowPath(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrierSlowPath</span><span class="params">(JSCell* obj)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (IsGcRunning()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMarked(obj)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (CompareAndSwap(</span><br><span class="line">         obj-&gt;cellState, black <span class="comment">/*from*/</span>, white <span class="comment">/*to*/</span>) == SUCCESS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMarked(obj)) &#123;</span><br><span class="line">          obj-&gt;cellState = black;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(isMarked(obj));   </span><br><span class="line">  &#125;</span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  <span class="comment">// Add 'obj' to remembered set</span></span><br><span class="line">  rmbSet.push(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC Marking phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty() || !rmbSet.empty()) &#123;</span><br><span class="line">  JSCell* obj = !<span class="built_in">queue</span>.empty() ? <span class="built_in">queue</span>.pop() : rmbSet.pop();</span><br><span class="line">  obj-&gt;cellState = black;       </span><br><span class="line">  StoreLoadFence();           <span class="comment">// Note the fence!</span></span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      markObject(child);</span><br><span class="line">      child-&gt;cellState = white; </span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Remove-Unnecessary-Memory-Fence-In-WriteBarrier">Remove Unnecessary Memory Fence In WriteBarrier</h4>
<p>The <code>WriteBarrier</code> is now free of hazardous race conditions. However, we are executing a <code>StoreLoadFence()</code> for every <code>WriteBarrier</code>, which is a very expensive CPU instruction. Can we optimize it?</p>
<p>The idea is the following: the fence is used to protect against race with GC. Therefore, we definitely need the fence if the GC is concurrently running. However, the fence is unnecessary if the GC is not running. Therefore, we can check if the GC is running first, and only execute the fence if the GC is indeed running.</p>
<p>JSC is even smarter: instead of having two checks (one that checks if the GC is running and one that checks if the <code>cellState</code> is <code>black</code>), it combines them into a single check for the fast-path where the GC is not running and the object is <code>white</code>. The trick is the following:</p>
<ol>
<li>Assume <code>black = 0</code> and <code>white = 1</code> in the <code>cellState</code> enum.</li>
<li>Create a global variable called <code>blackThreshold</code>. This <code>blackThreshold</code> is normally <code>0</code>, but at the beginning of a GC cycle, it will be set to <code>1</code>, and it will be reset back to <code>0</code> at the end of the GC cycle.</li>
<li>Now, check if <code>obj-&gt;cellState &gt; blackThreshold</code>.</li>
</ol>
<p>Then, if the check succeeded, we know we can immediately return: the only case this check can succeed is when the GC is not running and we are <code>white</code> (because <code>blackThreshold = 0</code> and <code>cellState = 1</code> is the only situation to pass the check). This way, the fast path only executes one check. If the check fails, then we fallback to the slow path, which performs the full procedure: check if GC is running, execute a fence if needed, then check if <code>cellState</code> is <code>black</code> again. In pseudo-code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrier</span><span class="params">(JSCell* obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj-&gt;cellState &gt; g_blackThreshold) &#123;</span><br><span class="line">    <span class="comment">// Fast-path: the only way to reach here is when</span></span><br><span class="line">    <span class="comment">// the GC is not running and the cellState is white</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!IsGcRunning()) &#123;</span><br><span class="line">    <span class="comment">// g_blackThreshold is 0, so our object is</span></span><br><span class="line">    <span class="comment">// actually black, we need to go to WriteBarrierSlowPath</span></span><br><span class="line">    WriteBarrierSlowPath(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// GC is running so we need to execute the fence </span></span><br><span class="line">    <span class="comment">// and check cellState again</span></span><br><span class="line">    StoreLoadFence(); </span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;cellState == black) &#123;</span><br><span class="line">      WriteBarrierSlowPath(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that there is no race between <code>WriteBarrier</code> and GC setting/clearing <code>IsGcRunning()</code> flag and changing the <code>g_blackThreshold</code> value, because the mutator is always stopped at a safe point (of course, halfway inside <code>WriteBarrier</code> is not a safe point) when the GC starts/finishes.</p>
<h4 id="“Obstruction-Free-Double-Collect-Snapshot”">“Obstruction-Free Double Collect Snapshot”</h4>
<p>Concurrent GC also introduced new complexities for the <code>ForEachChild</code> function used by GC marking phase to scan all objects referenced by a certain object. Each Javascript object has a <code>Structure</code> (aka, hidden class) that describes how the content of this object shall be interpreted into object fields. Since the GC marking phase is run concurrently with the mutator, and the mutator may change the <code>Structure</code> of the object, and may even change the size of the object’s butterfly, GC must be sure that despite the race conditions, it will never crash by dereferencing invalid pointers and never miss to scan a child. Using a lock is clearly infeasible for performance reasons. JSC uses a so-called <em>obstruction-free double collect snapshot</em> to solve this problem. Please refer to the <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/" target="_blank" rel="noopener">Webkit GC blog post</a> to see how it works.</p>
<h3 id="Some-Minor-Design-Details-and-Optimizations">Some Minor Design Details and Optimizations</h3>
<p>You might find this section helpful if you want to actually read and understand the code of JSC, but otherwise feel free to skip it: these details are not centric to the design, and are not particularly interesting either. I mention them only to bridge the gap between the GC scheme explained in this post and the actual implementation in JSC.</p>
<p>As explained earlier, each <code>CompleteSubspace</code> owns a list of <code>BlockDirectory</code> to handle allocations of different sizes; each <code>BlockDirectory</code> has an active block <code>m_currentBlock</code> where it allocates from, and it achieves this by holding a free list of all available cells in the block. But how does it work exactly?</p>
<p>As it turns out, each <code>BlockDirectory</code> has a <code>cursor</code>, which is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.cpp.html#_ZN3JSC14LocalAllocator5resetEv" target="_blank" rel="noopener">reset</a> to point at the beginning of the block list at the end of an eden or full GC cycle. Until it is reset, it can only move forward. The <code>BlockDirectory</code> will <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectory.cpp.html#_ZN3JSC14BlockDirectory22findBlockForAllocationERNS_14LocalAllocatorE" target="_blank" rel="noopener">move the cursor forward</a>, until it finds a block containing available cells, and allocate from it. If the cursor reaches the end of the list, it will attempt to <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.cpp.html#195" target="_blank" rel="noopener">steal a 16KB block</a> from another <code>BlockDirectory</code> and allocate from it. If that also failed, it will allocate a new 16KB block from OS and allocate from it.</p>
<p>I also mentioned that a <code>BlockDirectory</code> uses a free list to allocate from the currently active block <code>m_currentBlock</code>. It’s important to note that in the actual implementation of JSC, the cells in <code>m_currentBlock</code> does not respect the rule for <code>isNew</code> bit. Therefore, to check liveness, one either need to do a special-case check to see if the cell is from <code>m_currentBlock</code> (for example, see <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/HeapCell.cpp.html#_ZN3JSC8HeapCell6isLiveEv" target="_blank" rel="noopener">HeapCell::isLive</a>), or, for the GC<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>, stop the mutator, destroy the free list (and populate <code>isNew</code> in the process), do whatever inspection, then rebuild the free list and resume the mutator. The latter is implemented by <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle14stopAllocatingERKNS_8FreeListE" target="_blank" rel="noopener">two</a> <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle16resumeAllocatingERNS_8FreeListE" target="_blank" rel="noopener">functions</a> named <code>stopAllocating()</code> and <code>resumeAllocating()</code>, which are automatically called whenever the world is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/Heap.cpp.html#_ZN3JSC4Heap16stopThePeripheryENS_11GCConductorE" target="_blank" rel="noopener">stopped</a> or <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/Heap.cpp.html#_ZN3JSC4Heap18resumeThePeripheryEv" target="_blank" rel="noopener">resumed</a>.</p>
<p><a name="isNewAndAllocateBit"></a>The motivation of allowing <code>m_currentBlock</code> to not respect the rule for <code>isNew</code> is (a tiny bit of) performance. Instead of manually setting <code>isNew</code> to <code>true</code> for every allocation, a block-level bit <code>allocated</code> (aggregated as a bitvector in <code>BlockDirectory</code>) is used to indicate if a block is full of live objects. When the <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle18didConsumeFreeListEv" target="_blank" rel="noopener">free list becomes empty</a> (i.e., the block is fully allocated), we simply set <code>allocated</code> to <code>true</code> for this block. When querying cell liveness, we <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlockInlines.h.html#101" target="_blank" rel="noopener">check this bit first</a> and directly return true if it is set. The <code>allocated</code> bitvector is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectory.cpp.html#252" target="_blank" rel="noopener">cleared at the end of each GC cycle</a>, and since the global logical version for <code>isNew</code> is also bumped, this effectively clears all the <code>isNew</code> bits, just as we desired.</p>
<p>JSC’s design also support the so-called <em>constraint solver</em>, which allows specification of implicit reference edges (i.e., edge not represented as pointer in the object). This is mainly used to support Javascript interaction with DOM. This part is not covered in this post.</p>
<p>Weak reference has multiple implementations in JSC. The general (but less efficient) implementation is <code>WeakImpl</code>, denoting a weak reference edge. The data structure managing them is <code>WeakSet</code>, and you can see it in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.h.html#JSC::MarkedBlock::Handle::m_weakSet" target="_blank" rel="noopener">every block footer</a>, and in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation::m_weakSet" target="_blank" rel="noopener">every PreciseAllocation GC header</a>. However, JSC also employs more efficient specialized implementations to handle the weak map feature in Javascript. The details are not covered in this post.</p>
<p>In JSC, objects may also have destructors. There are three ways the destructors are run. First, when we begin allocating from a block, destructors of the dead cells are run. Second, the <code>IncrementalSweeper</code> periodically scans the blocks and runs destructors. Finally, when the VM shuts down, the <code>lastChanceToFinalize()</code> function is called to ensure that all destructors are run at that time. The details of <code>lastChanceToFinalize()</code> are not covered in this post.</p>
<p>JSC employs a conservative approach for pointers on the stack and in registers: the GC uses UNIX signals to suspend the mutator thread, so it can copy its stack contents and CPU register values to search for data that looks like pointers. However, it’s important to note that UNIX signal is <strong>not</strong> used to suspend the execution of the mutator: the mutator always <strong>actively</strong> suspends itself at a safe point. This is critical, as otherwise it could be suspended at weird places, for example, in a <code>HeapCell::isLive</code> check after it has read <code>isNew</code> but before it has read <code>isMarked</code>, and then GC did <code>isNew |= isMarked, isMarked = false</code>, and boom. So it seems like the only reason to suspend the thread is for the GC to get the CPU register values, including the <code>SP</code> register value so the GC knows where the stack ends. It’s unclear to me if it’s possible to do so in a cooperative manner instead of using costly UNIX signals.</p>
<h3 id="Acknowledgements">Acknowledgements</h3>
<p>I thank Saam Barati from JSC team for his enormous help on this blog post. Of course, any mistakes in this post are mine.</p>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Brief stop-the-world pause is still required at the start and end of each GC cycle, and may be intentionally performed if the mutator thread (i.e. the thread running Javascript code) is producing garbage too fast for the GC thread to keep up with. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>The actual allocation logic is implemented in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.h.html#JSC::LocalAllocator" target="_blank" rel="noopener">LocalAllocator</a>. Despite that in the code <code>BlockDirectory</code> is holding a linked list of <code>LocalAllocator</code>, (at time of writing, for the codebase version linked in this blog) the linked list always contains exactly one element, so the <code>BlockDirectory</code> and <code>LocalAllocator</code> is one-to-one and can be viewed as an integrated component. This relationship might change in the future, but it doesn’t matter for the purpose of this post anyway. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Since the footer resides at the end of a 16KB block, and the block is also 16KB aligned, one can do a simple bit math from any object pointer to access the footer of the block it resides in. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Similar to that per-cell information is aggregated and stored in the block footer, per-block information is aggregated as bitvectors and stored in <code>BlockDirectory</code> for fast lookup. Specifically, two bitvectors <code>empty</code> and <code>canAllocateButNotEmpty</code> track if a block is empty, or partially empty. The <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectoryBits.h.html#_M/FOR_EACH_BLOCK_DIRECTORY_BIT" target="_blank" rel="noopener">code</a> is relatively confusing because the bitvectors are <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectoryBits.h.html#JSC::BlockDirectoryBits::Segment" target="_blank" rel="noopener">layouted in a non-standard way</a> to make resizing easier, but conceptually it’s just one bitvector for each boolean per-block property. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>While seemingly straightforward, it is not straightforward at all (as you can see in the code). The free cells are marked free by the GC, and due to concurrency and performance optimization the logic becomes very tricky: we will revisit this later. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>In fact, it also <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.cpp.html#195" target="_blank" rel="noopener">attempts to steal</a> blocks from other allocators, and the OS memory allocator may have <a href="https://sillycross.github.io/r/WebKit/WTF/Headers/wtf/Gigacage.h.html" target="_blank" rel="noopener">some special requirements</a> required for the VM, but we ignore those details for simplicity. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>In the current implementation, the list of sizes (byte) are 16, 32, 48, 64, 80, then <code>80 * 1.4 ^ n</code> for <code>n &gt;= 1</code> up to about 8KB. Exponential growth guarantees that the overhead due to internal fragmentation is at most a fraction (in this case, 40%) of the total allocation size. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>An interesting implementation detail is that <code>IsoSubspace</code> and <code>CompleteSubspace</code> always return memory aligned to 16 bytes, but <code>PreciseAllocation</code> always return memory address that has reminder 8 module 16. This allows identifying whether an object is allocated by <code>PreciseAllocation</code> with a simple bit math. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>JSC has another small optimization here. Sometimes a <code>IsoSubspace</code> contains so few objects that it’s a waste to hold them using a 16KB memory page (the block size of <code>BlockDirectory</code>). So the first few memory pages of <code>IsoSubspace</code> use the so-called “lower-tier”, which are smaller memory pages allocated by <code>PreciseAllocation</code>. In this post, we will ignore this design detail for simplicity. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Memory of an <code>IsoSubspace</code> is only used by this <code>IsoSubspace</code>, never stolen by other allocators. As a result, a memory address in <code>IsoSubspace</code> can only be reused to allocate objects of the same type. So for any type <code>A</code> allocated by <code>IsoSubspace</code>, even if there is a use-after-free bug on type <code>A</code>, it is impossible to allocate <code>A</code>, free it, allocate type <code>B</code> at the same address, and exploit the bug to trick the VM into interpreting an integer field in <code>B</code> controlled by attacker as a pointer field in <code>A</code>. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>In some GC schemes, an eden object is required to survive two (instead of one) eden GC to be considered in old space. The purpose of such design is to make sure that any old space object is at least one eden-GC-gap old. In contrast, in JSC’s design, an object created immediately before an eden collection will be considered to be in old space immediately, which then can only be reclaimed via a full GC. The performance difference between the two designs is unclear to me. I conjecture JSC chose its current design because it’s easier to make concurrent. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>There is one additional color <code>Grey</code> in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/CellState.h.html#JSC::CellState" target="_blank" rel="noopener">the code</a>. However, it turns out that <code>White</code> and <code>Grey</code> makes no difference (you can verify it by grepping all use of <code>cellState</code> and observe that the only comparison on <code>cellState</code> is checking if it is <code>Black</code>). The comments explaining what the colors mean are also a bit outdated. This is likely a historical artifact. In my opinion JSC should really clean it up and update the comment, as it can easily cause confusion to readers who intend to understand the design. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>The bit is actually called <code>isNewlyAllocated</code> in the code. We shorten it to <code>isNew</code> for convenience in this post. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p><em>Safe point</em> is a terminology in GC. At a <em>safe point</em>, the heap and stack is in a coherent state understandable by the GC, so the GC can correctly trace out which objects are dead or live. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>For <code>PreciseAllocation</code>, all allocated objects are chained into a linked list, so we can traverse all objects (live or dead) easily. This is not efficient: we will explain the optimizations for <code>CompleteSubspace</code> later. <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Keep in mind that while this is true for now, as we add more optimizations to the design, this will no longer be true. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Note that we push the old space object into the queue, not the eden object, because this pointer could have been overwritten at the start of the GC cycle, making the eden object potentially collectable. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Also note that all objects dead before this GC cycle, i.e. the free cells of a block in <code>CompleteSubspace</code>, still have <code>isNew = false</code> and <code>isMarked = false</code>, as desired. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Recall that under generational hypothesis, most objects die young. Therefore, that “all objects in an eden block are found dead during eden GC” is something completely plausible. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>In JSC, the version is stored in a <code>uint32_t</code> and they have a bunch of logic to handle the case that it overflows <code>uint32_t</code>. In my humble opinion, this is an overoptimization that results in very hard-to-test edge cases, especially in a concurrent setting. So we will ignore this complexity: one can easily avoid these by spending 8 more bytes per block footer to have <code>uint64_t</code> version number instead. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Note that any number of eden GC cycles may have run between the last full GC cycle and the current full GC cycle, but eden GC does not bump mark version. So for any object born before the last GC cycle (no matter eden or full), the <code>isMarked</code> bit honestly reflect if it is live, and we will accept the bit as its mark version must be off-by-one. For objects born after the last GC cycle, it must have a latest <code>isNew</code> version, so we can know it’s alive through <code>isNew</code>. In both cases, the scheme correctly determines if an object is alive, just as desired. <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>And probably not: first, true sharing and false sharing between GC and mutator can cause slowdown. Second, as we have covered before, JSC uses a Time-Space Scheduler to prevent the mutator from allocating too fast while the GC is running. Specifically, the mutator will be intentionally suspended for at least 30% of the duration. So as long as the GC is running, the mutator suffers from an 30%-or-more “performance tax”. <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>The real story is a bit more complicated. JSC actually reuse the same VM for different Javascript scripts. However, at any moment, at most one of the script can be running. So technically, there are multiple mutually-exclusive mutator threads, but this doesn’t affect our GC story. <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>The GC needs to inspect a lot of cells, and its logic is already complex enough, so having one less special-case branch is probably beneficial for both engineering and performance. <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/06/02/2022-06-02/" data-id="cl5u9vg45000fnoolftzu7f00" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-05-31" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/05/31/2022-05-31/">NP70PNP + Ubuntu Tweak Notes</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2022/05/31/2022-05-31/" class="article-date"><time datetime="2022-05-31T00:00:00.000Z" itemprop="datePublished">2022-05-31</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Recently I decided to get a new laptop to replace my 5-years-old one. I happened to discover something called “barebone laptop”, which are essentially laptops with no RAM or SSD installed and no brand logo painted.</p>
<p>The barebone laptop manufacturers generally only provide bulk sale to OEM manufacturers. Since retail sale is not possible directly, there is a niche market for buying in barebone laptops in bulk and resell them to end customers, and there are small business who live on this niche, which is the easiest way for one to buy a barebone.</p>
<p>Apart from being more environment-friendly (by reusing the RAM and SSD from the old laptop), the main advantage of a barebone is the price. My new <code>Clevo NP70PNP</code> bought from R&amp;J Tech (a barebone reseller business) is $1300, while a <code>Dell</code> laptop with the identical configuration<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> is sold at $2650. It’s surprising that Dell at least doubled the price<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> by simply plugging in the RAM and SSD and painting their logo on top<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, and their customers are still happily buying it.</p>
<p>Anyway, let’s get back to the topic. My experience is that the <code>Clevo NP70PNP</code> can work very well with Ubuntu, though a few tweaks are needed. The hardest part is that it’s very hard to find the necessary tweaks in Google due to the unpopularity of barebone laptops, which is why I’m taking notes here.</p>
<ol>
<li>It has the Intel AX201 Wifi card, which doesn’t work in Ubuntu 20.04, and the reason is the kernel version, so not fixable by manually installing the firmware. However, Ubuntu 22.04 (just released last month) supports the Wifi card out of the box.</li>
<li>The Ubuntu 22.04 live-USB black screens on regular boot, but can be fixed by selecting <code>safe graphics</code> at boot menu. It’s a pain – for whatever reason it takes 10 minutes to load the desktop, but fortunately this is only needed for live-USB install: after the install, the GPU driver and the graphics work fine.</li>
<li>The touchpad (model <code>FTCS1000:01 2808:0102</code>) is the one that took me the longest to make work. It works initially, but would fail randomly after some time. After a lot of fruitless googling, it turns out that the GPU setting is the problem! (I seriously have no idea why.) As it turns out, the fix is to disable <code>MS Hybrid</code> for GPU. One can do this either in BIOS (in <code>Advanced Chip Settings</code>, switch the option from <code>MS Hybrid</code> to <code>Discrete GPU Only</code>), or in Ubuntu NVIDIA X Server Settings (in <code>PRIME settings</code> choose <code>Performance</code>).</li>
<li>Even after the tweak, there are still some minor issues with touchpad. Specifically, the feature that automatically disables touchpad when external mouse is present or while typing does not work, since for some reason the touchpad cannot be disabled from <code>xinput</code>. However, for some reason, it can still be disabled in GNOME by bash command <code>gsettings set org.gnome.desktop.peripherals.touchpad send-events disabled</code>. So I wrote a <code>udev</code> rule to automatically disable the touchpad on external mouse plugging in and re-enable it when the external mouse is plugged out. Googling any <code>udev</code> rule tutorial should be sufficient. Automatically disabling touchpad on typing seems much harder.</li>
<li>There are some minor issue with Bluetooth. For some reason, with AD2P Sink, there is a 0.5s delay in playing music. The problem doesn’t exist with HSP, though the audio quality of HSP is considerably lower. I haven’t figured out how to fix the problem since I usually use a headset.</li>
<li>For some reason, whenever the GPU is under load, the fan would spin at max speed (even if the GPU temperature is only 40 C or so), and the noise is a bit too loud. And it seems like neither the NVIDIA GPU driver nor <code>fancontrol</code> could even detect the fan, not to mention controlling it, though I haven’t dig into this issue too deep either, since it’s not too problematic for my use case.</li>
</ol>
<p>Other than the issues mentioned above, everything works out of the box under Ubuntu 22.04, including all my external devices and all <code>Fn</code> hotkeys (except the one that disables touchpad).</p>
<p>For the hardware side, IMO the model has only two minor design drawbacks: there are only two USB ports (and one of it is USB 2.0, seriously, why?); and the plastic hull seems relatively fragile and has many very thin parts, so I’m a bit concerned if the hull would break in an accident someday. The weight and the battery life are also not the best on the market, though they are definitely within reasonable range for a 17.3&quot; performance-oriented laptop, and also I’m not too concerned about them for my use case.</p>
<p>Overall, I would recommend it as a great laptop at a great price for Ubuntu users.</p>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>CPU model, GPU model, screen size, screen resolution are all identical. The barebone doesn’t come with RAM or SSD, but the Dell $2650 model has the worst RAM and SSD that is sold at $30 on Amazon. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>In fact, I would conjecture they tripled the price: given that R&amp;J is such a small business and how fast laptop hardware models get outdated, I guess the bulk bought-in price from Clevo is likely much less than $1000. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Of course, they also install Windows, but a Windows license not that expensive either, and also I don’t use Windows… <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/05/31/2022-05-31/" data-id="cl5u9vg3q000cnool396ict03" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-04-30" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/04/30/2022-04-30/">The Watchpoint Mechanism in JSC</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2022/04/30/2022-04-30/" class="article-date"><time datetime="2022-04-30T00:00:00.000Z" itemprop="datePublished">2022-04-30</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>While Javascript has a simple syntax, what happens behind the scene is far from simple. For example, consider this innocent-looking <code>hypot</code> function below:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hypot = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(a * a + b * b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is clear what <code>Math.sqrt</code> does: it performs a square root. However, to actually execute <code>Math.sqrt(...)</code>, a lot of steps are needed:</p>
<ol>
<li>First, get the global object, where all global variables reside in.</li>
<li>Then, get the <code>Math</code> property of the global object. Normally the <code>Math</code> property exists (since it is predefined), but we can’t know for sure: if someone had indeed run <code>delete Math;</code> before, we must promptly throw out an error.</li>
<li>Next, get the <code>sqrt</code> property of <code>Math</code>. Note that we cannot even be certain that <code>Math</code> is an object (as someone could have done <code>Math = 123;</code>). So as in (2), we must not omit any check for error.</li>
<li>Finally, similarly, what the <code>sqrt</code> property contains can be anything. Even if it is a function, it could be <em>any</em> function. So as before, we must not omit any check, and if <code>sqrt</code> is indeed a Javascript function, we perform the Javascript function call.</li>
</ol>
<p>So, in order to correctly (as every Javascript engine needs to be) execute this innocently looking <code>Math.sqrt</code>, a ton of stuffs must be done.</p>
<h4 id="How-can-we-make-this-faster">How can we make this faster?</h4>
<p>The crucial observation is that while the programmer is technically allowed to do anything, including insane things like <code>delete Math;</code> or <code>Math = 123</code>, most sane programs will not do it. So for practical purposes, it is enough if we can make sane programs both correct and fast, while running insane programs only correctly.</p>
<p>In JSC (<a href="https://webkit.org/" target="_blank" rel="noopener">WebKit</a>’s Javascript engine), this is achieved by <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/bytecode/Watchpoint.h.html#138" target="_blank" rel="noopener">Watchpoint</a>.</p>
<p>Conceptually, a <code>WatchpointSet</code> represents a condition that one expects to be true, or simply put, a <em>watchable condition</em>. For example, we may expect the global object to contain property <code>Math</code>, and its value being equal to the predefined <code>Math</code> object.</p>
<p>One may attach <code>Watchpoint</code>s to the <code>WatchpointSet</code>. A <code>Watchpoint</code> is essentially a callback: after attaching to a <code>WatchpointSet</code>, when the condition represented by the <code>WatchpointSet</code> becomes false, the callback is invoked (“fired”), so the owner who created the <code>Watchpoint</code> can react correspondingly.</p>
<p>While the watchpoint mechanism isn’t necessarily binded to JIT Compilation (for example, <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/bytecode/LLIntPrototypeLoadAdaptiveStructureWatchpoint.h.html#JSC::LLIntPrototypeLoadAdaptiveStructureWatchpoint" target="_blank" rel="noopener">LLIntPrototypeLoadAdaptiveStructureWatchpoint</a> works without JIT), it is most powerful when combined with JIT Compilation. We generate code that is optimized assuming the watchpoint condition holds, so inside the generated code, we don’t check for the condition at all. If the condition no longer holds, we must jettison the code – this is expensive, because all the work we did to generate the code is wasted, but the whole point of watchpoint is that such bad cases should happen only rarely.</p>
<h4 id="A-Motivating-Example">A Motivating Example</h4>
<p>Let’s go back to the <code>Math.sqrt</code> example: we want to get notified when a property of an object changes value. Therefore, all logic that writes value into object properties must cooperate with us. For simplicity, let’s assume the object <code>Math</code> has a <a href="https://webkit.org/blog/10308/speculation-in-javascriptcore/" target="_blank" rel="noopener">Structure</a>, say <code>S</code>. Then, there are two kinds of logic that may write to object properties:</p>
<ol>
<li>The C++ code that implements object property writes (the slow paths).</li>
<li>The JIT’ed code that writes to a specific property of a specific structure (the fast paths).</li>
</ol>
<p>The fast paths are known as <a href="https://webkit.org/blog/10308/speculation-in-javascriptcore/" target="_blank" rel="noopener">inline caches</a>. Inline caching is probably the most important optimization in JSC, but I will leave its details to another post. For the purpose of this post, it’s sufficient to think of each inline cache fast-path as a JIT-compiled piece of code that is specialized for a certain structure <code>S</code> and a certain property name <code>prop</code>. Given a <code>value</code> and an object with structure <code>S</code>, it writes <code>value</code> to property <code>prop</code> of the object.</p>
<p>The slow path case is easy to handle: whenever one writes to a property of an object, one checks whether there are Watchpoints watching the condition, and fire them. Of course, we are doing one extra check for every object property write. However, those code are already slow paths, so it doesn’t hurt too much to make them a bit more slower.</p>
<p>The fast path case is trickier. A naive solution is to add a watchpoint check, as how we handled slow-path. However, this is unsatisfactory: now, every fast-path write is doing one extra check! We can afford slowing down the slow-path, but we want to keep the fast-path fast.</p>
<p>So, the fast-path must not check for watchpoint conditions it violates at runtime. Instead, we <em>permenantly</em> invalidate any and all <code>WatchpointSet</code> it could violate as soon as the fast-path code is JIT’ed, no matter if there are watchers or not. As another consequence, since the fast path works on a fixed property (e.g. <code>sqrt</code>) of a fixed Structure (e.g. <code>S</code>), but not on fixed objects, our watchpoints have to be in the form of <code>&lt;Structure, property&gt;</code>: they work on Structure-level but not object-level (they are called <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/runtime/StructureRareData.h.html#JSC::StructureRareData::m_replacementWatchpointSets" target="_blank" rel="noopener">ValueReplacementWatchpointSet</a> in JSC). For example,when a fast-path writing the <code>sqrt</code> property of Structure <code>S</code> is built, we have to be conservative and permanently invalidate WatchpointSet <code>&lt;S, sqrt&gt;</code>, since we have no way to know if that fast-path is going to run on our <code>Math</code> object in the future.</p>
<h4 id="The-Design">The Design</h4>
<p>This leads to the following design in JSC. A <code>WatchpointSet</code> has three possible <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/bytecode/Watchpoint.h.html#JSC::WatchpointState" target="_blank" rel="noopener">states</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>:</p>
<ol>
<li><code>DoesNotExist</code>: The <code>WatchpointSet</code> object does not physically exist (and is implicitly <code>Valid</code>). This is needed because there is an infinite number of watchable conditions, and also that we want to save memory. In this state, there exists no fast-path that rely on or violate the watchpoint. Slowpath executions that violate the watchpoint are not recorded (but doing so wouldn’t break the scheme).</li>
<li><code>Valid</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>: The watchpoint is valid: no fast-path that may violate the watched condition has been built, and one may build fast-path relying on the watchpoint condition as long as it adds itself into the watcher list.</li>
<li><code>Invalidated</code>: The watchpoint is permaently invalidated.</li>
</ol>
<p>As one can see from the example in the previous section, the <code>Watchpoint</code> system needs to handle interactions with three components:</p>
<ol>
<li>Slow-path (C++ code) that may violate the watched condition.</li>
<li>Fast-path (JIT’ed code) that may violate the watched condition.</li>
<li>Code (C++ or JIT’ed) that is optimized assuming the watched condition is true.</li>
</ol>
<p>For (1), the slow-path must check in the code any watchable condition it violated, and if the corresponding <code>WatchpointSet</code> exists, fire all watchers. However, in such case, the slow-path have the choice between invalidate the <code>WatchpointSet</code>, or to keep it valid<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>.</p>
<p>For (2), the fast-path code does not check the watchable condition it violates, but we must transit all <code>WatchpointSet</code>s it may violate when executed to <code>Invalidated</code> when such a fast-path is JIT’ed (and we must create such <code>WatchpointSet</code> object if it does not exist yet).</p>
<p>For (3), we must disable the code when the watcher callback is invoked. If the code is C++ code, then disabling the codepath is as easy as flipping a flag. If the code is JIT’ed code, we must jettison the code<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>.</p>
<h4 id="Back-to-Our-Example-and-Adaptive-Watchpoints">Back to Our Example, and Adaptive Watchpoints</h4>
<p>Unfortunately, in our example, it turns out that only watching on <code>&lt;Structure, Property&gt;</code> is not enough. While this handles writes to <em>existing</em> properties correctly, one may create <em>new</em> properties in the object, thus transitioning its <code>Structure</code>. Say, one did a <code>Math.abc = 123;</code>. Since it adds a property to <code>Math</code>, the object <code>Math</code> gets a different structure <code>S2</code>, but our watchpoint is watching on <code>&lt;S, sqrt&gt;</code>, and we are screwed. To fix this issue, we must get notified when our object changes structure as well. However, as before, since an object-property-write fast-path works on a fixed <code>Structure</code> but not a fixed object, we have to put our watchpoint at <code>Structure</code> level. That is, we will have a <code>WachpointSet</code> on each Structure <code>S</code>, asserting that it never makes further transitions to other Structures (this is called a <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/runtime/Structure.h.html#JSC::Structure::m_transitionWatchpointSet" target="_blank" rel="noopener">StructureTransitionWatchpointSet</a> in JSC).</p>
<p>The last interesting piece is what to do when a StructureTransitionWatchpointSet turns to <code>Invalidated</code> state. If the transition happened on another object with the same Structure <code>S</code>, even though our <code>Math</code> object is not modified, we have no choice but to invalidate our code, as the StructureTransitionWatchpointSet for <code>S</code> has been invalidated, so we have no way to get notified if our <code>Math</code> object gets transitioned in the future.</p>
<p>However, if the transition happened on object <code>Math</code> (i.e. <code>Math</code> itself gets a new Structure), then it’s possible to keep our optimized code valid: we just need to start watching <code>&lt;S2, sqrt&gt;</code> instead. So we will move our ValueReplacementWatchpoint to watch <code>&lt;S2, sqrt&gt;</code> and our StructureTransitionWatchpoint to watch <code>S2</code>, and keep our code valid<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>. In JSC, such watchpoints whose action on fire is to move themselves to new places have a terminology <code>AdaptiveWatchpoints</code>.</p>
<h4 id="Ending-Thoughts">Ending Thoughts</h4>
<p>This way, by watching that the <code>Math</code> property of the global object never changes value, and that the <code>sqrt</code> property of the <code>Math</code> object never changes value, the code <code>Math.sqrt</code> is reduced from two object property lookups with a ton of error checks to a constant (not even a branch!) in the JIT’ed code.</p>
<p>The watchpoint mechanism also helps other optimizations to generate better code. For example, the call opcode (which calls whatever is stored in <code>Math.sqrt</code>) has its own inline caching that records which functions it has called. For sane programs that does not mess up with the predefined objects, there will be only one callee recorded: the <code>sqrt</code> intrinsic function. Normally this would allow the compiler to emit a check (that the result of expression <code>Math.sqrt</code> equals the <code>sqrt</code> intrinsic function) and speculatively inline <code>sqrt</code>. However, since the watchpoint already tells us that <code>Math.sqrt</code> <em>must</em> evaluates to the <code>sqrt</code> intrinsic function, the compiler can do better: it may omit the check and inline <code>sqrt</code> directly. Now, for sane programs, all the terrible stuffs listed at the beginning of this post are gone, so the JIT’ed code to evaluate the <code>Math.sqrt</code> part is as efficient as if it were directly written in C++!</p>
<p>Finally, a couple of side notes:</p>
<ol>
<li>If we want to avoid the case that the transition of another object results in invalidation of our code, we can give our object its own unique Structure, though the downside is that we might blow up the inline cache if we do it for too many objects.</li>
<li>The slow-path does not fire the watchpoint if the watchpoint is in <code>DoesNotExist</code> or <code>Clear</code> state. This not only saves memory, but is also an advantage for the use case above: while it’s plausible to assume that sane programs will not change <code>Math.sqrt</code> frequently, it’s also plausible for them to change it at program start (e.g., to log a warning if the input to <code>sqrt</code> is negative). Since such code will execute in slow-path and before any fast-path relying on the <code>WatchpointSet</code> is built, they will not invalidate the <code>WatchpointSet</code>, as desired.</li>
</ol>
<h4 id="Acknowledgements">Acknowledgements</h4>
<p>I thank Saam Barati from JSC team for teaching me all of these (and more) using his precious spare time, and for his valuable comments on this post. Of course, any mistakes in this post are mine.</p>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Note that the <code>DoesNotExist</code> state is not listed in the enum, since in this state the object doesn’t exist at all. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>In fact, JSC further distinguishes <code>Valid</code> state into <code>Clear</code> and <code>Watched</code>, to determine the behavior when a slow-path violation happened (see Footnote 3). However, this is only a design detail, so we put it in footnote for ease of understanding. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>When the <code>WatchpointSet</code> is in <code>Clear</code> state, the slow-path will keep it in <code>Clear</code> state. However, if it is in <code>Watched</code> state, even if there are no watchers, it will be transitioned to <code>Invalidated</code> state. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Things get trickier if the code is already running (e.g., the code being jettisoned is the current function being executed, a function in the call stack, or even a function inlined by the current function), in which case we must OSR Exit to the baseline tier, but we will ignore such complexities in this post. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Of course, if the ValueReplacementWatchpointSet of <code>&lt;S2, sqrt&gt;</code> or the StructureTransitionWatchpointSet of <code>S2</code> is already <code>Invalidated</code>, we will still have to invalidate our code. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/04/30/2022-04-30/" data-id="cl5u9vg3p000bnooleazb9q77" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-04-26" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/04/26/2022-04-26/">Note on x86-64 Memory Model</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2022/04/26/2022-04-26/" class="article-date"><time datetime="2022-04-26T00:00:00.000Z" itemprop="datePublished">2022-04-26</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>In the past years, I have undergone a few cycles of learning the x86-64 memory model, only to eventually forget it again. Today I was fortunate to see <a href="https://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf" target="_blank" rel="noopener">a great paper</a> which explained this matter very clearly, so I’m taking a note here for future reference.</p>
<p>The model in the paper is particularly easy to understand because it is described by standard software lock primitives<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, as below:</p>
<ol>
<li>There is one global lock <code>G</code>.</li>
<li>There is one background thread <code>T</code>.</li>
<li>Each CPU has a <em>store buffer</em>, which is a queue of items <code>&lt;address, value&gt;</code>. The store buffer is pushed by the owning CPU, and popped by the background thread <code>T</code>.</li>
</ol>
<p>The background thread <code>T</code> does only one thing:</p>
<ol>
<li>Lock global lock <code>G</code>.</li>
<li>Pop an item <code>&lt;addr, value&gt;</code> from the store buffer of a CPU, write the value to main memory: <code>MainMemory[addr] = value</code>.</li>
<li>Unlock global lock <code>G</code>.</li>
</ol>
<p>The procedure for a CPU to execute an instruction is described below.</p>
<h4 id="STORE-instruction">STORE instruction</h4>
<ol>
<li>Push item <code>&lt;addr, value&gt;</code> to its store buffer.</li>
</ol>
<h4 id="LOAD-instruction">LOAD instruction</h4>
<ol>
<li>Lock global lock <code>G</code>.</li>
<li>If <code>addr</code> exists in its store buffer, return corresponding <code>value</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. Otherwise return <code>MainMemory[addr]</code>.</li>
<li>Unlock global lock <code>G</code>.</li>
</ol>
<h4 id="MFENCE-instruction">MFENCE instruction</h4>
<ol>
<li>Wait until its store buffer is eventually emptied by background thread <code>T</code>.</li>
</ol>
<h4 id="ATOMIC-instruction">ATOMIC instruction</h4>
<ol>
<li>Lock global lock <code>G</code>.</li>
<li>Run the atomic instruction, using subroutines described above for <code>LOAD</code> and <code>STORE</code>.</li>
<li>Wait until its store buffer is eventually emptied by background thread <code>T</code>.</li>
<li>Unlock global lock <code>G</code>.</li>
</ol>
<p>Note that the semantics of <code>LOAD</code> and <code>STORE</code> provide the expected consistency on single-threaded programs.</p>
<h4 id="An-Application">An Application</h4>
<p>Let’s analyze why the familiar spinlock implementation below is correct under x86-64 memory model:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">uint8_t</span>* lock)</span> </span>&#123; *lock = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">(<span class="keyword">uint8_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!compare_and_swap(lock, <span class="number">0</span> <span class="comment">/*expect*/</span>, <span class="number">1</span> <span class="comment">/*desired*/</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unlock</span><span class="params">(<span class="keyword">uint8_t</span>* lock)</span> </span>&#123; </span><br><span class="line">    *lock = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We will prove the correctness via a token-counting argument. Each <code>&lt;lock, 0&gt;</code> in a store buffer counts as one token, and if <code>MainMemory[lock] == 0</code>, it also counts as one token. By definition at any moment the number of tokens cannot go below <code>0</code>.</p>
<p>By the abstract machine semantics above, it’s not hard to prove that:</p>
<ol>
<li>The background thread <code>T</code> cannot increase the total number of tokens.</li>
<li>Each <code>Unlock()</code> call creates one token.</li>
<li>Each <code>Lock()</code> call cannot return until it successfully consumes at least one token (If the CAS succeeded by seeing a <code>0</code> in its store buffer, that token is lost after the CAS because CAS flushes store buffer and also changes the memory value to 1. If the CAS succeeded by seeing a <code>0</code> in the main memory, that token is also lost because the store buffer item of the new value <code>1</code> is flushed to memory, overwriting the <code>0</code> value).</li>
</ol>
<p>Initially there is one token (by the <code>Init()</code> call). Since <code>Unlock()</code> may only be called after<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> (guaranteed by program order) <code>Lock()</code>, the total number of tokens cannot go above one at any moment. So after a <code>Lock()</code> returns, there must be zero tokens, so no other <code>Lock()</code> can return. The total number of tokens goes back to one only when the <code>Unlock()</code> in that program is called, and only after that other <code>Lock()</code> operation may return. So the <code>Lock() -&gt; Unlock()</code> time intervals are pairwisely non-overlapping, providing the mutual exclusiveness as one would expect.</p>
<hr>
<h5 id="Footnotes">Footnotes</h5>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Therefore, while the description is logically equivalent to the guarantees provided by the hardware, this is not how the hardware physically implements the memory subsystem. The hardware implementation is way more efficient. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Of course, if <code>addr</code> showed up multiple times in the store buffer, we should return the <code>value</code> of the latest version. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Throughout this argument, the time relationship is about wall clock time (or, the relative position in the interleaved event sequence of all CPUs). <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/04/26/2022-04-26/" data-id="cl5u9vg3o000anool1zk632m8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-04-01" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/04/01/2022-04-01/">From X Macro to FOR_EACH to Cartesian Product Enumeration with C Macro</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2022/04/01/2022-04-01/" class="article-date"><time datetime="2022-04-01T00:00:00.000Z" itemprop="datePublished">2022-04-01</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Quite a while ago I was implementing an interpreter. A common task in the interpreter is to select the correct interpreter function based on the type of the input. Let’s say we want to implement an addition. We might end up with something like below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(T* input1, T* input2, T* output)</span> </span>&#123;</span><br><span class="line">    *output = *input1 + *input2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>to implement the operation. At runtime, we want to dispatch to the right function base on the type of the operands. A natural way to do this is to have a static array holding the mapping from the operand type to the function pointer, similar to below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Type &#123; Int32, Int64, Double, ... &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">const</span> x_addOpPtr[] = &#123;</span><br><span class="line">    (<span class="keyword">void</span>*)Add&lt;<span class="keyword">int32_t</span>&gt;, </span><br><span class="line">    (<span class="keyword">void</span>*)Add&lt;<span class="keyword">int64_t</span>&gt;, </span><br><span class="line">    (<span class="keyword">void</span>*)Add&lt;<span class="keyword">double_t</span>&gt;, ...</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>so at runtime we can just read <code>x_addOpPtr[operandType]</code> to obtain the function pointer we want to call.</p>
<h4 id="The-X-Macro">The X Macro</h4>
<p>Although the code above can work, it is clearly too error prone. If we accidentally made a mistake in the order of the list, we are screwed. A better way is the <a href="https://en.wikipedia.org/wiki/X_Macro" target="_blank" rel="noopener">X Macro</a> pattern. We define a “X macro” for all the types:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_EACH_TYPE(X) \</span></span><br><span class="line">    X(Int32, <span class="keyword">int32_t</span>)    \</span><br><span class="line">    X(Int64, <span class="keyword">int64_t</span>)    \</span><br><span class="line">    X(Double, <span class="keyword">double_t</span>) ...</span><br></pre></td></tr></table></figure>
<p>Then, by defining what <code>X(EnumType, CppType)</code> expands to, we can create logic based on our needs. For example, the following code would reproduce the <code>x_addOpPtr</code> array we want:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(EnumType, CppType) (void*)Add<span class="meta-string">&lt;CppType&gt; , </span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">const</span> x_addOpPtr[] = &#123; </span><br><span class="line">    FOR_EACH_TYPE(X) </span><br><span class="line">    <span class="literal">nullptr</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> X	<span class="comment">// hygiene </span></span></span><br></pre></td></tr></table></figure>
<p>Note that the final <code>nullptr</code> is needed because our expansion <code>(void*)Add&lt;CppType&gt;,</code> would generate an extra comma in the end.</p>
<h4 id="The-New-Challenge">The New Challenge</h4>
<p>X Macro solved the above problem, but what if we want to handle, say, a type cast opcode?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Src, <span class="keyword">typename</span> Dst&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cast</span><span class="params">(Src* input, Dst* output)</span> </span>&#123;</span><br><span class="line">    *output = <span class="keyword">static_cast</span>&lt;Dst&gt;(*input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unlike the addition operator, now we have two types <code>Src</code> and <code>Dst</code> to enumerate on, so we have to generate a two-dimensional array. While X Macro can easily iterate through one list and perform action on every item, it cannot iterate through the <strong>Cartesian product of two lists</strong>. A worse solution, is of course, to manually define a list containing all the <code>&lt;Src, Dst&gt;</code> pairs, so we can do X macro again. But what if we want to do a three-dimensional Cartesian product in the future?</p>
<p>After some fruitless Googling and home-making attempts to build a “two dimensional X Macro”, I eventually gave up and switched to <a href="https://github.com/sillycross/PochiVM/blob/master/pochivm/ast_type_helper.h#L635" target="_blank" rel="noopener">an ugly solution</a>. Instead of generating a clean static array, we generate a tree of templated dispatching functions. The function at the <code>i-th</code> level use a dispatch array (built by X macro) to dispatch to the next level’s selector function based on the <code>i-th</code> parameter type. We get the function pointer when we reach the leaf. While this approach works, no doubt it is very ugly, and probably also less performant (I didn’t check if the C++ compiler were able to optimize away all the terrible things).</p>
<h4 id="The-FOR-EACH-Macro">The FOR_EACH Macro</h4>
<p>I used to believe my ugly solution is as good as one can get without resorting to manually enumerating the Cartesian product. However, today I learnt <a href="https://www.scs.stanford.edu/~dm/blog/va-opt.html" target="_blank" rel="noopener">an interesting approach</a> from David Mazieres, which he calls the <code>FOR_EACH</code> macro.</p>
<p>The semantics of the <code>FOR_EACH</code> macro is pretty clear. Taking a macro <code>X</code> (similar to the <code>X</code> in X Macro) and a comma-separated list of elements <code>e1, e2, ... , en</code>, the <code>FOR_EACH</code> macro invokes <code>X</code> on each <code>e</code> in the list. For example, the addition example would look like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that the 'X' is gone, and the list is comma-separated</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_LIST        \</span></span><br><span class="line">    (Int32, <span class="keyword">int32_t</span>) ,   \</span><br><span class="line">    (Int64, <span class="keyword">int64_t</span>) ,   \</span><br><span class="line">    (Double, <span class="keyword">double_t</span>) ...  </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(e) (void*)Add<span class="meta-string">&lt;TUPLE_GET_2(e)&gt; ,</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">const</span> x_addOpPtr[] = &#123; </span><br><span class="line">    FOR_EACH(X, TYPE_LIST) </span><br><span class="line">    <span class="literal">nullptr</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br></pre></td></tr></table></figure>
<p>The most important difference between <code>FOR_EACH</code> macro and X Macro is that the <code>FOR_EACH</code> list definition doesn’t take <code>X</code>. Unlike the X Macro, where the macro to call on each element is hardcoded to only pass the element itself, the <code>FOR_EACH</code> macro decoupled “the element to be processed” and “the macro processing the element”. This removes the biggest blocker to implement a macro that can enumerate through Cartesian product of multiple lists.</p>
<p>The core of the trick which allows <code>FOR_EACH</code>’s list definition to get rid of the <code>X</code> lies in the <a href="https://en.cppreference.com/w/cpp/preprocessor/replace#Function-like_macros" target="_blank" rel="noopener">C++20 new feature</a> <code>__VA_OPT__</code>. David Mazieres’ original article is already a good explanation on how the <code>FOR_EACH</code> macro works so I won’t parrot it again. With the main blocker removed, after only a few hours of work, I was able to successfully extend <code>FOR_EACH</code> to support enumerating through the Cartesian product of multiple lists. (By the way, even after implementing it, I still have very little idea on how the C preprocessor works, but <code>clang++ -E</code> is enough to trial-and-error into a working solution).</p>
<h4 id="The-FOR-EACH-CARTESIAN-PRODUCT-Macro">The FOR_EACH_CARTESIAN_PRODUCT Macro</h4>
<p>I call my macro <code>FOR_EACH_CARTESIAN_PRODUCT</code>. As the name suggests, it takes a macro <code>X</code> and one or more lists <code>(L1), ..., (Ln)</code>. Then for each <code>(e1, ..., en)</code> in the Cartesian product <code>L1 x ... x Ln</code> , the macro <code>X(e1, ..., en)</code> is invoked. The elements in the Cartesian product are enumerated in lexical order.</p>
<p>For example, for the type-casting example above, the below code would construct our desired two-dimensional dispatch array:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(e1, e2) (void*)Cast<span class="meta-string">&lt;TUPLE_GET_2(e1), TUPLE_GET_2(e2)&gt; ,</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">const</span> x_castOpPtr[] = &#123; </span><br><span class="line">    FOR_EACH_CARTESIAN_PRODUCT(X, (TYPE_LIST), (TYPE_LIST)) </span><br><span class="line">    <span class="literal">nullptr</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br></pre></td></tr></table></figure>
<p>Note that the generated array is one-dimensional, but indexing it is pretty simple: <code>x_castOpPtr[opType1 * numTypes + opType2]</code> will give us the desired function pointer for <code>Src=opType1</code> and <code>Dst=opType2</code>.</p>
<p>The code, which contains both the implementation for <code>FOR_EACH_CARTESIAN_PRODUCT</code> and the above examples <a href="https://sillycross.github.io/assets/2022-04-01/for-each-cartesian-product-macro.cpp.txt" target="_blank" rel="noopener">can be found here</a>. The code is in public domain so feel free to use.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/04/01/2022-04-01/" data-id="cl5u9vg3n0009nool7av5guoh" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-10-24" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2021/10/24/2021-10-24/">Some Random Thoughts</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2021/10/24/2021-10-24/" class="article-date"><time datetime="2021-10-24T00:00:00.000Z" itemprop="datePublished">2021-10-24</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Recently I attended the <a href="https://2021.splashcon.org/track/splash-2021-oopsla#event-overview" target="_blank" rel="noopener">OOPSLA 2021</a> conference. While I haven’t barely learnt anything from the conference itself, it’s indeed a break from my routine life, and I have probably met more people than the sum of the past few months. So as a result, I had some random thoughts and reflections, which I decide to take notes here before they disappear.</p>
<h4 id="Methodology-of-Decision-Making">Methodology of Decision Making</h4>
<p>It is well known that one should not judge a decision based on its outcome, because we cannot have full awareness of the world (so there are information that we <em>cannot</em> know beforehand), and the world itself also contains many random factors (so we cannot predict the future even with complete information). Therefore, an undesirable outcome does not imply the original decision is wrong or improvable.</p>
<p>However, humans are born irrational. Many never understand the above argument at all. But even within the people who can recognize it, I have seen (on both myself and others) many cognitive pitfalls when applying the argument.</p>
<p><em>Pitfall #1.</em> Only apply when things go wrong. Ego makes people believe in their own decisions. So when things work out, it’s easy to overlook the possibility that the success is only coincidental and the original decision is unjustifiable.<br>
As an extreme example, winning a lottery does not justify the decision of spending large amounts of money buying lotteries (which has a negative expected gain).</p>
<p><em>Pitfall #2.</em> Overlooking the information one can know. Similarly, due to people’s ego, when something fails, it’s easy to use the argument as an excuse to deny responsibility, not realizing that the original decision could have been improved with more investigation and reasoning.<br>
The most obvious examples are decisions made through overconfidence and negligence.</p>
<p><em>Pitfall #3.</em> Overlooking the information one cannot know. As stated earlier, one cannot have complete information of the world, so that “there are information that one cannot know” is also an information that must be considered in decision making.<br>
Examples of this pitfall are “perfect plans” that are designed without backups and leaves no buffer on accidents and errors.</p>
<p>So in short, one should not judge a decision based on its outcome, be it desirable or not; one should judge a decision based on the <em>justifiability</em> of how the decision is reached.</p>
<p>(Interestingly, everything stated above can also be observed in <a href="https://en.wikipedia.org/wiki/Japanese_Mahjong" target="_blank" rel="noopener">Japanese Mahjong</a>)</p>
<h4 id="Methodology-of-Becoming-Productive-Researchers">Methodology of Becoming Productive Researchers</h4>
<p>I am aware that all my research ideas have been produced by pure luck. If one had rewinded time, I’m very doubtful if I could come up with the same ideas again. And I feel it clueless to figure out the “next idea” like some of the PhD students who are more “on the right track” could easily do. So I have been curious how the professors can generate an endless stream of ideas for papers. I happened to have discussed this topic with two professors, so for future reference, I take notes here based on my memory.</p>
<p>Q1: (The context here is theoretical computer science.) The difficulty of figuring out a proof is probably exponential to the number of the steps in the proof. So how can you and your group produce so many long (&gt;50 pages) papers every year?</p>
<p>A1 (Richard): We are not going for particular problems. Instead, we have a set of powerful math tools as building blocks, and we just build things up by gluing the blocks together, without a particular goal in mind. If at some time we found that the thing we built solved some problem, we have a paper. It’s like a naval battle: you don’t search for and destroy a particular ship (problem) on the sea. You patrol the sea and destroy any ship spotted along the way.</p>
<p>Q2: But I assume you still have some intuition on what might work and what might not. What is the intuition that guides you and how did you get this intuition?</p>
<p>A2 (Richard): I don’t know. It’s like the first man who figured out they can put guns on ships.</p>
<p>Q3: (The context here is PL/Compilers, and my advisor primarily works on sparse tensor algebra.) I asked my advisor how he could always have the next paper idea to work on.</p>
<p>A3 (Fred): There are many solved problems in the dense algebra domain, but little is known about the sparse algebra counterparts. <a href="http://fredrikbk.com/publications/taco.pdf" target="_blank" rel="noopener">TACO</a> is a framework for solving problems in the sparse algebra domain, so it opens up a sequence of works by porting the solved problems in dense algebra to sparse algebra.</p>
<h4 id="What-Prevents-Constructive-and-Rational-Discussion">What Prevents Constructive and Rational Discussion?</h4>
<p>The motivation of this part is the (still ongoing!) Chinese Internet shitshow centered around a consipracy theory that the Grand Final match of <a href="https://liquipedia.net/dota2/The_International/2021" target="_blank" rel="noopener">Dota2 TI10</a> is fixed.</p>
<p>I have never held any expectation on the rationality of the mass public, but I’m still astonished by that a conspiracy theory without even a self-coherent story can get dominance in the Chinese Dota2 community.</p>
<p>Though it might be my illusion, but I do feel the Internet discussions I see on contemporary matters have been getting increasingly polarized / emotion-driven, and decreasingly constructive / helpful in the past years. Is the mass public becoming more irrational? I don’t know. But after thinking for a bit, I do feel there are a few contributing factors.</p>
<ol>
<li>It takes much more words and time to refute a conspiracy theory or to post some serious discussion, than to propose a conspiracy theory or to post some trashtalk.</li>
<li>The bandwidth of the Internet has greatly increased, but the bandwidth of the useful information being carried has actually decreased. On one hand, blogs are replaced by tweets, texts are replaced by pictures/videos, so the mass public has been trained to only read short messages, not serious discussions. On the other hand, mobile phones, which are not even designed to type efficiently, have surpassed the market occupation rate of PCs long ago, so it is also harder for the mass public to publish anything other than short messages. So the mass public has been trained to only read 140 characters and post 140 characters, not any serious discussions.</li>
<li>By Pareto principle, 80% of the voice in a community comes from 20% of the people. And the people who feel most compelled to speak out are usually the people holding the most extreme opinions. But under the current shape of the Internet, where serious discussions are unfavored, the megaphone is handed over to the most irrational ones, not the most rational ones.</li>
<li>The ranking mechanism, where contents are ranked by user votes and shown to users by rank, served as another amplifier.</li>
<li>But what about the POLs? Will they send out rational messages and lead the public opinions to the rational side? Unfortunately, at least for the Chinese Internet’s status quo, where most of the POLs are commercialized, the answer is negative. The POLs do not care about anything but making more money, which come from public exposure and supporters. So they have no motivation to argue against the trend at all. In fact, many POLs are known to intentionally start flamewars or spread falsehood messages to gain exposure.</li>
<li>Another interesting factor is the bots. It might be surprising, but a <a href="https://www.cmu.edu/ambassadors/july-2020/covid-falsehoods.html" target="_blank" rel="noopener">CMU research</a> showed that the majority of the COVID falsehood messages on Twitter are spreaded by bots. And while I haven’t seen an academic research for the Chinese Internet, it’s undeniable that there are many keyword-based bots for various purposes (lottery, advertisement, promotion, PR manipulation, etc). It’s not surprising that there are similar falsehood message bots as well.</li>
</ol>
<p>But what exactly went wrong? And how this might be fixed? Honestly I don’t know.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2021/10/24/2021-10-24/" data-id="cl5u9vg3m0008nool7tx2c1ds" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-09-20" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2021/09/20/2021-09-20/">Understanding JavaScriptCore&#39;s DFG JIT: CPS Rethreading Pass</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2021/09/20/2021-09-20/" class="article-date"><time datetime="2021-09-20T00:00:00.000Z" itemprop="datePublished">2021-09-20</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>This is another note on JavaScriptCore (JSC)'s DFG JIT. The topic today is on DFG’s IR design and a related optimizer pass called <em>CPS Rethreading</em>. As before, disclaimer first:</p>
<blockquote>
<p><strong>Disclaimer</strong><br>
I do not work on JavaScriptCore, and my experience with Javascript is very limited. Everything described in this post is from my understanding of the JSC source code. They may be inaccurate or outright wrong. Please feel free to email me at haoranxu510 [at] gmail.com for any corrections and discussions.</p>
</blockquote>
<!-- In my opinion, the most interesting design choices of DFG's IR are centered around how it handles variables. I will start with a quick introduction of DFG's IR. -->
<p>In DFG’s IR, each function consists of a list of <a href="https://en.wikipedia.org/wiki/Basic_block" target="_blank" rel="noopener">basic blocks</a>, and each basic block contains a list of IR intructions. An IR instruction is also implicitly the value this instruction produces, and can be used as operand to other IR instructions. Everything till now is similar to a typical <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener">SSA representation</a>. However, there are two important differences:</p>
<ol>
<li>Each IR instruction can only use the SSA values (implicitly produced by other IR instructions) in the <strong>same</strong> basic block.</li>
<li>Unlike in SSA, DFG does <strong>not</strong> have an IR instruction named “Phi”. Instead, in DFG’s IR, each function has a list of “slots”, which are local variables that one can read from and write to. There are two IR instructions <code>GetLocal</code> and <code>SetLocal</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> which allows reading/writing a slot respectively.</li>
</ol>
<p>As one would expect, a <code>GetLocal</code> takes a slot number constant as operand, and produces an SSA value. A <code>SetLocal</code> takes an SSA value (i.e., an IR instruction that produces a value) and a slot number constant as operands, and produces nothing.</p>
<p>The above representation (called <code>LoadStore</code> form in JSC) is very flexible for users to generate the IR, but not good for optimization, because in such representation it is hard to reason about the data stored in local variables. This is where the CPS Rethreading pass comes in, which transforms the graph to the so-called <code>ThreadedCPS</code> form. The CPS rethreading pass optimizes away redundant loads, adds <strong>auxiliary</strong> Phi nodes that describe the data flow of loads and stores, and also performs <a href="https://en.wikipedia.org/wiki/Live_variable_analysis" target="_blank" rel="noopener">liveness analysis</a>.</p>
<p>The most interesting design choice here is that the Phi nodes are auxiliary and optional, and are <em>not</em> part of the IR graph: the correctness of the IR graph is not affected even if all Phi nodes were removed, and by doing so, it only puts the graph back to <code>LoadStore</code> form.</p>
<p>As a result, a transformation pass may choose to either maintain the Phi nodes and the liveness information, or simply mark that the graph has been put back to <code>LoadStore</code> form (and then the CPS Rethreading pass can be called to bring it to <code>ThreadedCPS</code> form again).</p>
<p>The extra information available in <code>ThreadedCPS</code> form is the following:</p>
<ol>
<li>Each basic block gets a list of auxiliary Phi nodes. Unlike Phi nodes in SSA form, the Phi node here is parametrized by a slot number constant, so it denotes the value of that local variable at the start of the basic block. Those Phi nodes are only referenced by other Phi nodes (from other basic blocks) and by the stuffs below. They are never used by a normal IR instruction as operand.</li>
<li>Each basic block gets two auxiliary arrays <code>variablesAtHead</code> and <code>variablesAtTail</code> of length <code>N</code> (where <code>N</code> is the total number of local variable slots of the function). The <code>variablesAtHead</code> array denotes the value of all <a href="https://en.wikipedia.org/wiki/Live_variable_analysis" target="_blank" rel="noopener">live variables</a> at the start of the basic block. The <code>variablesAtTail</code> array denotes the value of all available (defined here as either live at the start of the basic block, or modified inside the basic block) variables at the end of the basic block.</li>
<li>Each <code>GetLocal</code> node gets an auxiliary pointer which denotes the value this <code>GetLocal</code> would yield. The pointer points to either a value-producing instruction in the same basic block (which means the <code>GetLocal</code> would yield that value), or a Phi node in the same basic block (which means the <code>GetLocal</code> would yield the value of the Phi).</li>
<li>Redundant <code>GetLocal</code>s to the same local variable in the same basic block are removed. There are two cases:<br>
(a). A <code>GetLocal</code> after another <code>GetLocal</code> can be replaced by the previous <code>GetLocal</code>.<br>
(b). A <code>GetLocal</code> after a <code>SetLocal</code> can be replaced by the operand of the <code>SetLocal</code>.</li>
</ol>
<p>There are a few points that are worth to note:</p>
<ol>
<li>Point (2) above implies that the total space consumption is <code>O(NM)</code> where <code>N</code> is the total number of local variable slots and <code>M</code> is the number of basic blocks.</li>
<li>Redundant <code>SetLocal</code>s to the same local variable inside the same basic block are not removed. Probably it has something to do with OSR.</li>
<li>The design above makes sure that all the extra information (most notably, the Phi nodes) are auxiliary: they can be safely dropped without affecting correctness.</li>
</ol>
<h4 id="The-Algorithm">The Algorithm</h4>
<p>The algorithm is implemented in <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGCPSRethreadingPhase.cpp" target="_blank" rel="noopener">DFGCPSRethreadingPhase.cpp</a>. For simplicity, as before, we will focus on <code>GetLocal</code> and <code>SetLocal</code> only, and ignore <code>Flush</code>, <code>PhantomLocal</code>, <code>SetArgumentDefinitely</code> and <code>SetArgumentMaybe</code> related logic.</p>
<p>The first step of the algorithm resets the existing state in case the pass has been invoked earlier. It clears the <code>variablesAtHead</code> and <code>variablesAtTail</code> array for each basic block, removes all Phi nodes, and reserves the space for the annotation pointer for each <code>GetLocal</code> node (by simply repurposes the unused <code>child1</code> field).</p>
<p>In the second step, for each basic block, it iterates all the IR instructions from up to down. The <code>variablesAtTail</code> array is used as a scratchpad to keep track of the current value of each variable at the current IR instruction being iterated.</p>
<ol>
<li>If it is a <code>GetLocal</code> instruction, and <code>variablesAtTail[i]</code> is <code>nullptr</code>, then this is the first time the variable <code>i</code> is used in this basic block, and the value of this variable should come from a Phi node. So we create a Phi node and store it into <code>variablesAtHead[i]</code>. The <code>variablesAtTail[i]</code> should also be updated to the current <code>GetLocal</code> node<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</li>
<li>If it is a <code>GetLocal</code> instruction, but <code>variablesAtTail[i]</code> is not <code>nullptr</code>, then the local variable <code>i</code> has been used in this basic block. Thus, this <code>GetLocal</code> can always be removed from the graph by replacing it with another node (with detail described earlier). Thanks to the design of the IR, this <code>GetLocal</code> may only be used by later IR instructions in the same basic block, so the replacement can be done easily<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>.</li>
<li>If it is a <code>StoreLocal</code> instruction, then we can simply update the corresponding slot in <code>variablesAtTail</code>.</li>
</ol>
<p>The third step builds the incoming edges for all Phi nodes. The Phi nodes created in the previous step are put into a list<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>. The algorithm iterates until the list gets empty. Each time an element, let’s say, a Phi node for some variable <code>i</code> in basic block <code>B</code>, is removed from the list. Then for all predecessors <code>P</code> of basic block <code>B</code>:</p>
<ol>
<li>If <code>P.variablesAtTail[i]</code> is <code>nullptr</code>, then there isn’t a Phi node in <code>P</code> for local variable <code>i</code> yet. So, a new one is created, and <code>P.variablesAtHead[i]</code> and <code>P.variablesAtTail[i]</code> is updated. The newly created Phi node is put into the list.</li>
<li>Otherwise, the predecessor of the current Phi node for that basic block should simply be <code>P.variablesAtTail[i]</code><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>.</li>
</ol>
<p>Note that the second step and the third step also guarantee that <code>variablesAtHead</code> correctly contains the information for all live variables at the start of a basic block.</p>
<h4 id="Conclusion">Conclusion</h4>
<p>In my opinion, the design of the DFG IR is really neat. The standard SSA form is best suited for optimization, but it is both difficult and slow to construct and transform. The DFG IR made interesting design choices that intentionally deviates from the standard SSA form to improve compilation speed and usability. This matches DFG JIT’s design goal as a fast optimizer. The CPS Rethreading pass is a neat algorithm that serves multiple purposes simultaneously: to simplify and canonicalize the IR, to construct a SSA-like Phi data flow, and to perform liveness analysis.</p>
<hr>
<h5 id="Footnotes">Footnotes</h5>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>In fact, there are also <code>Flush</code> and <code>PhantomLocal</code> which are related to OSR, and <code>SetArgumentDefinitely</code> and <code>SetArgumentMaybe</code> which are related to special casing of arguments, but we will overlook them in this article for simplicity. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>It seems like the algorithm intentionally updates it to the <code>GetLocal</code> node instead of the Phi node because it can provide more information to users: one can easily trace to the Phi from the <code>GetLocal</code> but not otherwise around. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Specifically, all we need to do is to maintain the replacement map, and at the time we iterate a node, we check if any of its operands are in the replacement map. If yes, we replace it. The replacement map can simply be a <code>std::map</code>, but a hash table lookup is still slow, so in JSC there is a 8-byte scratch field in each <code>Node</code> struct that can be used for this purpose (or other similar purposes). <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>In fact, there are three different kinds of local variables: <code>Argument</code>, <code>Local</code> and <code>Tmp</code>. So correspondingly, there are three different lists. I think it’s only an implementation detail: the three list could have been merged into one, but the current code design (where the <code>Kind</code> is used as a template parameter in several APIs) makes it easiest to just have three lists. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>The actual implementation is a bit more complex. If the predecessor node is a <code>GetLocal</code>, it would further forward it to the value of the <code>GetLocal</code> (as computed in the auxiliary pointer), but if the predecessor node is a <code>StoreLocal</code>, it won’t forward it to its operand. But these are only implementation details to best fit the needs of the clients (the other optimization passes), so we omit them to highlight the core idea. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2021/09/20/2021-09-20/" data-id="cl5u9vg3l0007noolhlrc5255" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-09-12" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="2021/09/12/2021-09-12/">Static Analysis in JavaScriptCore (Part I)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="2021/09/12/2021-09-12/" class="article-date"><time datetime="2021-09-12T00:00:00.000Z" itemprop="datePublished">2021-09-12</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Recently I’ve been spending time to understand some internals of JavaScriptCore (JSC), the Javascript JIT compiler powering the Safari browser. For background knowledge, I strongly recommend <a href="https://webkit.org/blog/10308/speculation-in-javascriptcore/" target="_blank" rel="noopener">this great article from WebKit blog</a> for a detailed overview of JSC.</p>
<p>This series of posts attempts to dive deeper into a specific area of JSC: the static analysis passes in JSC’s DFG JIT. Since Javascript is a highly dynamic langauge, it is critical to obtain as much type information as possible to better understand program behaviors so optimizations can take place. In JSC, static analysis is the primary tool for this purpose.</p>
<!--
As explained in the WebKit blog article, there are three most powerful static analysis passes: 
1. Prediction propagation, which fills in speculated types of all values based on the runtime profile of some values. 
2. Abstract interpreter, which, among other things, allows identifying redundant type speculation checks.
3. Clobberize, which as the name suggests, performs alias analysis. It allows elimination of redundant loads and code motion. 
-->
<p>The WebKit blog article gave a good overview of the analysis passes. However, since static analyses are hueristic algorithms, the concrete algorithm design is as important as (if not more important than) the high-level idea to yield a working solution. I’m also curious about the other static analysis passes performed by JSC that are not covered in the article.</p>
<p>So I decided to dive into the implementation to get a better understanding of the full picture. This turns out to be much harder than I expected, primarily due to the lack of comments in the codebase. So I’m taking notes here for future reference.</p>
<blockquote>
<p><strong>Disclaimer</strong><br>
I do not work on JavaScriptCore, my experience with Javascript is very limited, and I do not have prior experience on static analysis. Everything described in this post is from my understanding of the JSC source code. They may be inaccurate or outright wrong. Please feel free to email me at haoranxu510 [at] gmail.com for any corrections and discussions.</p>
</blockquote>
<h3 id="Specialized-DFG-IR-Node-Type">Specialized DFG IR Node Type</h3>
<p>The first optimization is not an optimization pass, but happens when the DFG IR is generated from the source-of-truth bytecode. For certain operations, there exists a specialized version of IR node type in addition to the general version. For example, <code>ValueAdd</code> handles the general addition that makes no assumption on operand types, while <code>ArithAdd</code> handles the case where both operands are statically known to be numbers (e.g., not <code>String</code> or <code>BigInt</code> or <code>Object</code>).</p>
<p>The logic that selects between the two versions can be found <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp#L5870" target="_blank" rel="noopener">here</a>. As one can see from the code, if the IR node types for the two operands both always return <code>Number</code> result (the <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGNodeType.h" target="_blank" rel="noopener">IR node type list</a> maintains what each node type may return), then an <code>ArithAdd</code> is emitted instead of <code>ValueAdd</code>. Since this is before any analysis or optimizations are run, there isn’t anything fancy here: all it checks is the IR node type.</p>
<p>Side notes:</p>
<ul>
<li>I found <a href="https://bugs.webkit.org/attachment.cgi?id=352782&amp;action=diff" target="_blank" rel="noopener">this diff</a>, which introduced the <code>ValueSub</code> opcode, quite helpful to understand what’s going on here.</li>
<li>I wasn’t able to figure out why the criteria for selecting <code>ArithAdd</code> is <code>op1-&gt;hasNumberResult() &amp;&amp; op2-&gt;hasNumberResult()</code>. The <code>if</code>-check rules out result types that are more precise than <code>Number</code> (e.g., <code>Int32</code>, <code>Int52</code> or <code>Double</code>), but I can’t see the reason to rule out such cases.</li>
</ul>
<h3 id="Backward-Propagation-Pass">Backward Propagation Pass</h3>
<p><a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp" target="_blank" rel="noopener">Backward propagation</a> is the first static analysis pass executed by the DFG JIT.</p>
<p>The backward propagation pass computes five flags for each DFG IR node. The flags are stored as part of [the <code>NodeFlags</code> field]((https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGNodeFlags.h) in each node. The definitions for the five flags are listed below, as per comments in the code:</p>
<ul>
<li><code>UsesAsNumber</code>: whether the node result may be used in a context that observes fractional, or bigger-than-int32, results.</li>
<li><code>UsesAsOther</code>: whether the node result may be used in a context that distinguishes between <code>undefined</code> and <code>NaN</code>.</li>
<li><code>NeedsNegZero</code>: whether the node result may be used in a context that distinguishes between <code>+0</code> and <code>-0</code>.</li>
<li><code>UsesAsInt</code>: whether the node result may be used in a context that prefers (but not requires) <code>int</code> values.</li>
<li><code>UsesAsArrayIndex</code>: whether the node result may be used in a context that strongly prefers <code>int</code> values.</li>
</ul>
<p>For the first three flags, not setting a flag that ought to be set is a correctness issue.</p>
<p>For example, if the flag <code>UsesAsOther</code> is not set, but a node <code>x</code> is actually used in a context that distinguished <code>undefined</code> and <code>NaN</code> (e.g., <code>x + &quot;123&quot;</code>), then the program may be misoptimized, and the user may observe unexpected result for that computation (e.g., getting <code>&quot;NaN123&quot;</code> instead of <code>&quot;undefined123&quot;</code>).</p>
<p>The <code>NeedsNegZero</code> flag seems (<a href="https://bugs.webkit.org/show_bug.cgi?id=113862" target="_blank" rel="noopener">based on this bug report</a>) to enable some <code>-0</code> related optimizations. For example, <code>a + (-0)</code> can be optimized to <code>a</code> by speculating <code>a</code> to be not <code>-0</code>. The speculation is usually worth because <code>-0</code> is rare, but it’s better to not speculate at all: if <code>a + (-0)</code> is part of a larger expression, and we can prove that even if <code>a + (-0)</code> were <code>-0</code>, the result of the full expression would be the same as if it were <code>0</code>, then we can omit the speculation. One example where speculation <code>a != (-0)</code> can be omitted is <code>(a + (-0)) + 1</code>, and one counterexample where speculation <code>a != (-0)</code> is required is <code>1 / (a + (-0))</code>. This is what the flag tries to determine.</p>
<p>The <code>UsedAsNumber</code> flag, based on my guess (<a href="https://trac.webkit.org/changeset/145489/webkit" target="_blank" rel="noopener">from this commit</a>), is designed to enable a special Javascript-specific optimization: Javascript bit-operators cast input to <code>int32</code> and also outputs <code>int32</code>, so certain overflow checks can be eliminated if the output is fed into a bit-operator (for example, in <code>(a + 1) | 0</code>, if <code>a</code> were speculated as an <code>int32_t</code>, the overflow check for <code>a + 1</code> may be omitted). It’s pretty tricky as seen from the related code and I can’t fully understand how the logic and optimization works. Given also that it seems to be a Javascript-specific optimization, I will overlook this flag below.</p>
<p>For the last two flags, however, not setting a flag that ought to be set is merely a performance issue and does not affect correctness.</p>
<p><a href="https://bugs.webkit.org/attachment.cgi?id=229754&amp;action=diff" target="_blank" rel="noopener">The motivation</a> for <code>UseAsArrayIndex</code> flag is that the conversion from a <code>double</code> to <code>int</code> is an expensive instruction, and since it is used as array index, it could be inside a loop and cause a big performance impact, so we should avoid this bad case if possible.</p>
<h4 id="The-Algorithm">The Algorithm</h4>
<p>In the <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGNodeType.h#L579" target="_blank" rel="noopener">initial state</a> of a node, all the five flags are not set. The backward propagation pass is executed to set up the five flags (and it must set the first three flags correctly <em>for correctness</em>).</p>
<p>The backward propagation pass is a monotonic process. Each flag may only be switched from <code>unset</code> to <code>set</code>, but not the other way. This makes sure that a fixed point (where further execution of the pass can result in no state changes) is guaranteed to be eventually reached. However, this also means that if at one point we set a flag which condition actually never happens in reality, there is no way to undo the bad decision.</p>
<p>The pass iterates until the fixpoint is reached. In each iteration, it does the following:</p>
<ul>
<li>Iterate each basic block in reverse order.</li>
<li>Iterate each IR instruction node in the basic block in reverse order.</li>
<li>For the current IR node, use its flags to update the flags of its operand (i.e., children) nodes. The concrete update logic depends on the node type, and is handwritten.</li>
</ul>
<p>Since there are close to 400 different IR node types, for correctness, the <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp#L156" target="_blank" rel="noopener">default operation</a> (for a node type not handled in the switch-case) is conservative: it sets the first three flags in all its operands.</p>
<p>As another conservative measure, even for node types that are explicitly handled, the default flags to propagate is the flags of the current node. So flags are propagated all the way down by default, and only stopped when the logic is explicitly written to <em>not</em> propagate a flag.</p>
<p>We will use <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp#L281" target="_blank" rel="noopener">the logic for <code>ValueAdd</code></a> and <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp#L296" target="_blank" rel="noopener">the logic for <code>ArithAdd</code></a> as examples to illustrate how the algorithm works.</p>
<p>For <code>ArithAdd</code>, since we already know the two operands must be <code>Number</code>s, it’s safe to not set the <code>UsesAsOther</code> flag for its operands. And if at least one of the operands is known to be not a <code>-0</code>, then the result of the add must not be a <code>-0</code> as well, so the <code>-0</code> in the operand will not be observable after the add, so in this case it’s safe to not set the <code>NeedsNegZero</code> flag for both operands.</p>
<p><code>ValueAdd</code> is similar to <code>ArithAdd</code>, except that it may take non-<code>Number</code> operands. In that case, <code>undefined</code> and <code>NaN</code> in operand may be distinguished (for example, in <code>x + &quot;123&quot;</code>). Therefore, for <code>ValueAdd</code>, the <code>UsesAsOther</code> flag is only not propagated if at least one of the operand is known to produce numeric results (in that case, if the other side is <code>undefined</code> or <code>NaN</code>, the final result is always the same, so the two are indistinguishable). Note that such criteria is not complete (sufficient but not necessary): but this is as far as static analysis can go.</p>
<p>Side notes:</p>
<ul>
<li>I couldn’t fully understand the purpose or implementations of the <code>UsedAsNumber</code> flag. Any explanations would be welcomed.</li>
<li>The pass did not handle operators like <code>ValueSub</code>, <code>ValueMul</code>, etc. It seems to me the developers forgot to update the pass when those operators are introduced.</li>
</ul>
<p>One interesting thing is about the “conservative” measures implemented in the code to reduce the risk of correctness bugs. If my interpretation that the devs forgot to put <code>ValueSub</code>, <code>ValueMul</code>, etc. into the pass is correct, then on one hand, the conservative measures indeed prevented a correctness bug. But on the other hand, since no correctness bug is produced, it would take a long time to figure out that the pass has become outdated and has been silently producing suboptimal results.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2021/09/12/2021-09-12/" data-id="cl5u9vg3k0006nooler2yfxya" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  


  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="archives/2022/">2022</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="archives/2021/">2021</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list-recent-posts">
      
        <li>
          <a href="2022/07/18/2022-07-18/">How to check if a real number is an integer in C++?</a>
        </li>
      
        <li>
          <a href="2022/06/11/2022-06-11/">Bizarre Performance Characteristics of Alder Lake CPU</a>
        </li>
      
        <li>
          <a href="2022/06/02/2022-06-02/">Understanding GC in JSC From Scratch</a>
        </li>
      
        <li>
          <a href="2022/05/31/2022-05-31/">NP70PNP + Ubuntu Tweak Notes</a>
        </li>
      
        <li>
          <a href="2022/04/30/2022-04-30/">The Watchpoint Mechanism in JSC</a>
        </li>
      
    </ul>
  </div>




        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 Haoran Xu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>-->

<script src="js/bootstrap/bootstrap.min.js"></script>



  
<link rel="stylesheet" href="fancybox/jquery.fancybox.css">

  
<script src="fancybox/jquery.fancybox.pack.js"></script>




<script src="js/script.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
 

</body>
</html>
