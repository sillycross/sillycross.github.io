<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Static Analysis in JavaScriptCore (Part I) | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Recently I’ve been spending time to understand some internals of JavaScriptCore (JSC), the Javascript JIT compiler powering the Safari browser. For background knowledge, I strongly recommend this grea">
<meta property="og:type" content="article">
<meta property="og:title" content="Static Analysis in JavaScriptCore (Part I)">
<meta property="og:url" content="https://sillycross.github.io/2021/09/12/2021-09-12/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Recently I’ve been spending time to understand some internals of JavaScriptCore (JSC), the Javascript JIT compiler powering the Safari browser. For background knowledge, I strongly recommend this grea">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-09-12T00:00:00.000Z">
<meta property="article:modified_time" content="2022-10-09T00:16:26.126Z">
<meta property="article:author" content="Haoran Xu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../../../../atom.xml" title="" type="application/atom+xml">
  
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
    
<link rel="stylesheet" href="../../../../css/source_code_pro.css">

  

  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">-->
  
<link rel="stylesheet" href="../../../../css/bootstrap/bootstrap.min.css">


  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="../../../../css/styles.css">

  

  
  <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->
  
<script src="../../../../js/jquery.min.js"></script>


<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="../../../../index.html">Home</a></li>
        
          <li><a class=""
                 href="../../../../archives/">Archives</a></li>
        
          <li><a class=""
                 href="../../../../about/">About</a></li>
        
          <li><a class=""
                 href="../../../../cnblog/">Chinese Blog</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title"></h1>
  
    <p class="blog-description">「こんなきれいな星も、やっぱりここまで来てから、見れたのだと思うから。だから・・もっと遠くへ・・」</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-2021-09-12" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Static Analysis in JavaScriptCore (Part I)
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="" class="article-date"><time datetime="2021-09-12T00:00:00.000Z" itemprop="datePublished">2021-09-12</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Recently I’ve been spending time to understand some internals of JavaScriptCore (JSC), the Javascript JIT compiler powering the Safari browser. For background knowledge, I strongly recommend <a href="https://webkit.org/blog/10308/speculation-in-javascriptcore/" target="_blank" rel="noopener">this great article from WebKit blog</a> for a detailed overview of JSC.</p>
<p>This series of posts attempts to dive deeper into a specific area of JSC: the static analysis passes in JSC’s DFG JIT. Since Javascript is a highly dynamic langauge, it is critical to obtain as much type information as possible to better understand program behaviors so optimizations can take place. In JSC, static analysis is the primary tool for this purpose.</p>
<!--
As explained in the WebKit blog article, there are three most powerful static analysis passes: 
1. Prediction propagation, which fills in speculated types of all values based on the runtime profile of some values. 
2. Abstract interpreter, which, among other things, allows identifying redundant type speculation checks.
3. Clobberize, which as the name suggests, performs alias analysis. It allows elimination of redundant loads and code motion. 
-->
<p>The WebKit blog article gave a good overview of the analysis passes. However, since static analyses are hueristic algorithms, the concrete algorithm design is as important as (if not more important than) the high-level idea to yield a working solution. I’m also curious about the other static analysis passes performed by JSC that are not covered in the article.</p>
<p>So I decided to dive into the implementation to get a better understanding of the full picture. This turns out to be much harder than I expected, primarily due to the lack of comments in the codebase. So I’m taking notes here for future reference.</p>
<blockquote>
<p><strong>Disclaimer</strong><br>
I do not work on JavaScriptCore, my experience with Javascript is very limited, and I do not have prior experience on static analysis. Everything described in this post is from my understanding of the JSC source code. They may be inaccurate or outright wrong. Please feel free to email me at haoranxu510 [at] gmail.com for any corrections and discussions.</p>
</blockquote>
<h3 id="Specialized-DFG-IR-Node-Type">Specialized DFG IR Node Type</h3>
<p>The first optimization is not an optimization pass, but happens when the DFG IR is generated from the source-of-truth bytecode. For certain operations, there exists a specialized version of IR node type in addition to the general version. For example, <code>ValueAdd</code> handles the general addition that makes no assumption on operand types, while <code>ArithAdd</code> handles the case where both operands are statically known to be numbers (e.g., not <code>String</code> or <code>BigInt</code> or <code>Object</code>).</p>
<p>The logic that selects between the two versions can be found <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp#L5870" target="_blank" rel="noopener">here</a>. As one can see from the code, if the IR node types for the two operands both always return <code>Number</code> result (the <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGNodeType.h" target="_blank" rel="noopener">IR node type list</a> maintains what each node type may return), then an <code>ArithAdd</code> is emitted instead of <code>ValueAdd</code>. Since this is before any analysis or optimizations are run, there isn’t anything fancy here: all it checks is the IR node type.</p>
<p>Side notes:</p>
<ul>
<li>I found <a href="https://bugs.webkit.org/attachment.cgi?id=352782&amp;action=diff" target="_blank" rel="noopener">this diff</a>, which introduced the <code>ValueSub</code> opcode, quite helpful to understand what’s going on here.</li>
<li>I wasn’t able to figure out why the criteria for selecting <code>ArithAdd</code> is <code>op1-&gt;hasNumberResult() &amp;&amp; op2-&gt;hasNumberResult()</code>. The <code>if</code>-check rules out result types that are more precise than <code>Number</code> (e.g., <code>Int32</code>, <code>Int52</code> or <code>Double</code>), but I can’t see the reason to rule out such cases.</li>
</ul>
<h3 id="Backward-Propagation-Pass">Backward Propagation Pass</h3>
<p><a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp" target="_blank" rel="noopener">Backward propagation</a> is the first static analysis pass executed by the DFG JIT.</p>
<p>The backward propagation pass computes five flags for each DFG IR node. The flags are stored as part of [the <code>NodeFlags</code> field]((https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGNodeFlags.h) in each node. The definitions for the five flags are listed below, as per comments in the code:</p>
<ul>
<li><code>UsesAsNumber</code>: whether the node result may be used in a context that observes fractional, or bigger-than-int32, results.</li>
<li><code>UsesAsOther</code>: whether the node result may be used in a context that distinguishes between <code>undefined</code> and <code>NaN</code>.</li>
<li><code>NeedsNegZero</code>: whether the node result may be used in a context that distinguishes between <code>+0</code> and <code>-0</code>.</li>
<li><code>UsesAsInt</code>: whether the node result may be used in a context that prefers (but not requires) <code>int</code> values.</li>
<li><code>UsesAsArrayIndex</code>: whether the node result may be used in a context that strongly prefers <code>int</code> values.</li>
</ul>
<p>For the first three flags, not setting a flag that ought to be set is a correctness issue.</p>
<p>For example, if the flag <code>UsesAsOther</code> is not set, but a node <code>x</code> is actually used in a context that distinguished <code>undefined</code> and <code>NaN</code> (e.g., <code>x + &quot;123&quot;</code>), then the program may be misoptimized, and the user may observe unexpected result for that computation (e.g., getting <code>&quot;NaN123&quot;</code> instead of <code>&quot;undefined123&quot;</code>).</p>
<p>The <code>NeedsNegZero</code> flag seems (<a href="https://bugs.webkit.org/show_bug.cgi?id=113862" target="_blank" rel="noopener">based on this bug report</a>) to enable some <code>-0</code> related optimizations. For example, <code>a + (-0)</code> can be optimized to <code>a</code> by speculating <code>a</code> to be not <code>-0</code>. The speculation is usually worth because <code>-0</code> is rare, but it’s better to not speculate at all: if <code>a + (-0)</code> is part of a larger expression, and we can prove that even if <code>a + (-0)</code> were <code>-0</code>, the result of the full expression would be the same as if it were <code>0</code>, then we can omit the speculation. One example where speculation <code>a != (-0)</code> can be omitted is <code>(a + (-0)) + 1</code>, and one counterexample where speculation <code>a != (-0)</code> is required is <code>1 / (a + (-0))</code>. This is what the flag tries to determine.</p>
<p>The <code>UsedAsNumber</code> flag, based on my guess (<a href="https://trac.webkit.org/changeset/145489/webkit" target="_blank" rel="noopener">from this commit</a>), is designed to enable a special Javascript-specific optimization: Javascript bit-operators cast input to <code>int32</code> and also outputs <code>int32</code>, so certain overflow checks can be eliminated if the output is fed into a bit-operator (for example, in <code>(a + 1) | 0</code>, if <code>a</code> were speculated as an <code>int32_t</code>, the overflow check for <code>a + 1</code> may be omitted). It’s pretty tricky as seen from the related code and I can’t fully understand how the logic and optimization works. Given also that it seems to be a Javascript-specific optimization, I will overlook this flag below.</p>
<p>For the last two flags, however, not setting a flag that ought to be set is merely a performance issue and does not affect correctness.</p>
<p><a href="https://bugs.webkit.org/attachment.cgi?id=229754&amp;action=diff" target="_blank" rel="noopener">The motivation</a> for <code>UseAsArrayIndex</code> flag is that the conversion from a <code>double</code> to <code>int</code> is an expensive instruction, and since it is used as array index, it could be inside a loop and cause a big performance impact, so we should avoid this bad case if possible.</p>
<h4 id="The-Algorithm">The Algorithm</h4>
<p>In the <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGNodeType.h#L579" target="_blank" rel="noopener">initial state</a> of a node, all the five flags are not set. The backward propagation pass is executed to set up the five flags (and it must set the first three flags correctly <em>for correctness</em>).</p>
<p>The backward propagation pass is a monotonic process. Each flag may only be switched from <code>unset</code> to <code>set</code>, but not the other way. This makes sure that a fixed point (where further execution of the pass can result in no state changes) is guaranteed to be eventually reached. However, this also means that if at one point we set a flag which condition actually never happens in reality, there is no way to undo the bad decision.</p>
<p>The pass iterates until the fixpoint is reached. In each iteration, it does the following:</p>
<ul>
<li>Iterate each basic block in reverse order.</li>
<li>Iterate each IR instruction node in the basic block in reverse order.</li>
<li>For the current IR node, use its flags to update the flags of its operand (i.e., children) nodes. The concrete update logic depends on the node type, and is handwritten.</li>
</ul>
<p>Since there are close to 400 different IR node types, for correctness, the <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp#L156" target="_blank" rel="noopener">default operation</a> (for a node type not handled in the switch-case) is conservative: it sets the first three flags in all its operands.</p>
<p>As another conservative measure, even for node types that are explicitly handled, the default flags to propagate is the flags of the current node. So flags are propagated all the way down by default, and only stopped when the logic is explicitly written to <em>not</em> propagate a flag.</p>
<p>We will use <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp#L281" target="_blank" rel="noopener">the logic for <code>ValueAdd</code></a> and <a href="https://github.com/WebKit/WebKit/blob/8d5e5fd60f0712a47548a3b84c397836c481db75/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp#L296" target="_blank" rel="noopener">the logic for <code>ArithAdd</code></a> as examples to illustrate how the algorithm works.</p>
<p>For <code>ArithAdd</code>, since we already know the two operands must be <code>Number</code>s, it’s safe to not set the <code>UsesAsOther</code> flag for its operands. And if at least one of the operands is known to be not a <code>-0</code>, then the result of the add must not be a <code>-0</code> as well, so the <code>-0</code> in the operand will not be observable after the add, so in this case it’s safe to not set the <code>NeedsNegZero</code> flag for both operands.</p>
<p><code>ValueAdd</code> is similar to <code>ArithAdd</code>, except that it may take non-<code>Number</code> operands. In that case, <code>undefined</code> and <code>NaN</code> in operand may be distinguished (for example, in <code>x + &quot;123&quot;</code>). Therefore, for <code>ValueAdd</code>, the <code>UsesAsOther</code> flag is only not propagated if at least one of the operand is known to produce numeric results (in that case, if the other side is <code>undefined</code> or <code>NaN</code>, the final result is always the same, so the two are indistinguishable). Note that such criteria is not complete (sufficient but not necessary): but this is as far as static analysis can go.</p>
<p>Side notes:</p>
<ul>
<li>I couldn’t fully understand the purpose or implementations of the <code>UsedAsNumber</code> flag. Any explanations would be welcomed.</li>
<li>The pass did not handle operators like <code>ValueSub</code>, <code>ValueMul</code>, etc. It seems to me the developers forgot to update the pass when those operators are introduced.</li>
</ul>
<p>One interesting thing is about the “conservative” measures implemented in the code to reduce the risk of correctness bugs. If my interpretation that the devs forgot to put <code>ValueSub</code>, <code>ValueMul</code>, etc. into the pass is correct, then on one hand, the conservative measures indeed prevented a correctness bug. But on the other hand, since no correctness bug is produced, it would take a long time to figure out that the pass has become outdated and has been silently producing suboptimal results.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="https://sillycross.github.io/2021/09/12/2021-09-12/" data-id="cl90lhv8n0007bvon0t9adnyc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="../../03/2021-09-03/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">Some Experiment Notes on Pitching and Storytelling</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="../../20/2021-09-20/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">Understanding JavaScriptCore&#39;s DFG JIT: CPS Rethreading Pass</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  


  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../../../../archives/2022/">2022</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../../../../archives/2021/">2021</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list-recent-posts">
      
        <li>
          <a href="../../../../2022/10/02/2022-10-02/">Pitfalls of using C++ Global Variable Constructor as a Registration Mechanism</a>
        </li>
      
        <li>
          <a href="../../../../2022/07/18/2022-07-18/">How to check if a real number is an integer in C++?</a>
        </li>
      
        <li>
          <a href="../../../../2022/06/11/2022-06-11/">Bizarre Performance Characteristics of Alder Lake CPU</a>
        </li>
      
        <li>
          <a href="../../../../2022/06/02/2022-06-02/">Understanding GC in JSC From Scratch</a>
        </li>
      
        <li>
          <a href="../../../../2022/05/31/2022-05-31/">NP70PNP + Ubuntu Tweak Notes</a>
        </li>
      
    </ul>
  </div>




        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 Haoran Xu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>-->

<script src="../../../../js/bootstrap/bootstrap.min.js"></script>



  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
 

</body>
</html>
