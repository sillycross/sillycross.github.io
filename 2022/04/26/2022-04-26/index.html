<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Note on x86-64 Memory Model | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="In the past years, I have undergone a few cycles of learning the x86-64 memory model, only to eventually forget it again. Today I was fortunate to see a great paper which explained this matter very cl">
<meta property="og:type" content="article">
<meta property="og:title" content="Note on x86-64 Memory Model">
<meta property="og:url" content="2022/04/26/2022-04-26/index.html">
<meta property="og:site_name">
<meta property="og:description" content="In the past years, I have undergone a few cycles of learning the x86-64 memory model, only to eventually forget it again. Today I was fortunate to see a great paper which explained this matter very cl">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-26T00:00:00.000Z">
<meta property="article:modified_time" content="2022-06-04T06:40:22.865Z">
<meta property="article:author" content="Haoran Xu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../../../../atom.xml" title="" type="application/atom+xml">
  
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
    
<link rel="stylesheet" href="../../../../css/source_code_pro.css">

  

  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">-->
  
<link rel="stylesheet" href="../../../../css/bootstrap/bootstrap.min.css">


  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="../../../../css/styles.css">

  

  
  <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->
  
<script src="../../../../js/jquery.min.js"></script>


<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="../../../../index.html">Home</a></li>
        
          <li><a class=""
                 href="../../../../archives/">Archives</a></li>
        
          <li><a class=""
                 href="../../../../about/">About</a></li>
        
          <li><a class=""
                 href="../../../../cnblog/">Chinese Blog</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title"></h1>
  
    <p class="blog-description">「こんなきれいな星も、やっぱりここまで来てから、見れたのだと思うから。だから・・もっと遠くへ・・」</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-2022-04-26" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Note on x86-64 Memory Model
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="" class="article-date"><time datetime="2022-04-26T00:00:00.000Z" itemprop="datePublished">2022-04-26</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>In the past years, I have undergone a few cycles of learning the x86-64 memory model, only to eventually forget it again. Today I was fortunate to see <a href="https://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf" target="_blank" rel="noopener">a great paper</a> which explained this matter very clearly, so I’m taking a note here for future reference.</p>
<p>The model in the paper is particularly easy to understand because it is described by standard software lock primitives<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, as below:</p>
<ol>
<li>There is one global lock <code>G</code>.</li>
<li>There is one background thread <code>T</code>.</li>
<li>Each CPU has a <em>store buffer</em>, which is a queue of items <code>&lt;address, value&gt;</code>. The store buffer is pushed by the owning CPU, and popped by the background thread <code>T</code>.</li>
</ol>
<p>The background thread <code>T</code> does only one thing:</p>
<ol>
<li>Lock global lock <code>G</code>.</li>
<li>Pop an item <code>&lt;addr, value&gt;</code> from the store buffer of a CPU, write the value to main memory: <code>MainMemory[addr] = value</code>.</li>
<li>Unlock global lock <code>G</code>.</li>
</ol>
<p>The procedure for a CPU to execute an instruction is described below.</p>
<h4 id="STORE-instruction">STORE instruction</h4>
<ol>
<li>Push item <code>&lt;addr, value&gt;</code> to its store buffer.</li>
</ol>
<h4 id="LOAD-instruction">LOAD instruction</h4>
<ol>
<li>Lock global lock <code>G</code>.</li>
<li>If <code>addr</code> exists in its store buffer, return corresponding <code>value</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. Otherwise return <code>MainMemory[addr]</code>.</li>
<li>Unlock global lock <code>G</code>.</li>
</ol>
<h4 id="MFENCE-instruction">MFENCE instruction</h4>
<ol>
<li>Wait until its store buffer is eventually emptied by background thread <code>T</code>.</li>
</ol>
<h4 id="ATOMIC-instruction">ATOMIC instruction</h4>
<ol>
<li>Lock global lock <code>G</code>.</li>
<li>Run the atomic instruction, using subroutines described above for <code>LOAD</code> and <code>STORE</code>.</li>
<li>Wait until its store buffer is eventually emptied by background thread <code>T</code>.</li>
<li>Unlock global lock <code>G</code>.</li>
</ol>
<p>Note that the semantics of <code>LOAD</code> and <code>STORE</code> provide the expected consistency on single-threaded programs.</p>
<h4 id="An-Application">An Application</h4>
<p>Let’s analyze why the familiar spinlock implementation below is correct under x86-64 memory model:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">uint8_t</span>* lock)</span> </span>&#123; *lock = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">(<span class="keyword">uint8_t</span>* lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!compare_and_swap(lock, <span class="number">0</span> <span class="comment">/*expect*/</span>, <span class="number">1</span> <span class="comment">/*desired*/</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unlock</span><span class="params">(<span class="keyword">uint8_t</span>* lock)</span> </span>&#123; </span><br><span class="line">    *lock = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We will prove the correctness via a token-counting argument. Each <code>&lt;lock, 0&gt;</code> in a store buffer counts as one token, and if <code>MainMemory[lock] == 0</code>, it also counts as one token. By definition at any moment the number of tokens cannot go below <code>0</code>.</p>
<p>By the abstract machine semantics above, it’s not hard to prove that:</p>
<ol>
<li>The background thread <code>T</code> cannot increase the total number of tokens.</li>
<li>Each <code>Unlock()</code> call creates one token.</li>
<li>Each <code>Lock()</code> call cannot return until it successfully consumes at least one token (If the CAS succeeded by seeing a <code>0</code> in its store buffer, that token is lost after the CAS because CAS flushes store buffer and also changes the memory value to 1. If the CAS succeeded by seeing a <code>0</code> in the main memory, that token is also lost because the store buffer item of the new value <code>1</code> is flushed to memory, overwriting the <code>0</code> value).</li>
</ol>
<p>Initially there is one token (by the <code>Init()</code> call). Since <code>Unlock()</code> may only be called after<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> (guaranteed by program order) <code>Lock()</code>, the total number of tokens cannot go above one at any moment. So after a <code>Lock()</code> returns, there must be zero tokens, so no other <code>Lock()</code> can return. The total number of tokens goes back to one only when the <code>Unlock()</code> in that program is called, and only after that other <code>Lock()</code> operation may return. So the <code>Lock() -&gt; Unlock()</code> time intervals are pairwisely non-overlapping, providing the mutual exclusiveness as one would expect.</p>
<hr>
<h5 id="Footnotes">Footnotes</h5>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Therefore, while the description is logically equivalent to the guarantees provided by the hardware, this is not how the hardware physically implements the memory subsystem. The hardware implementation is way more efficient. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Of course, if <code>addr</code> showed up multiple times in the store buffer, we should return the <code>value</code> of the latest version. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Throughout this argument, the time relationship is about wall clock time (or, the relative position in the interleaved event sequence of all CPUs). <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="2022/04/26/2022-04-26/" data-id="cl3ziaegj000ae4on4gu6b8b8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="../../01/2022-04-01/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">From X Macro to FOR_EACH to Cartesian Product Enumeration with C Macro</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="../../30/2022-04-30/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">The Watchpoint Mechanism in JSC</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  


  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../../../../archives/2022/">2022</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../../../../archives/2021/">2021</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="../../../06/02/2022-06-02/">Understanding GC in JSC From Scratch</a>
        </li>
      
        <li>
          <a href="../../../05/31/2022-05-31/">NP70PNP + Ubuntu Tweak Notes</a>
        </li>
      
        <li>
          <a href="../../30/2022-04-30/">The Watchpoint Mechanism in JSC</a>
        </li>
      
        <li>
          <a href="">Note on x86-64 Memory Model</a>
        </li>
      
        <li>
          <a href="../../01/2022-04-01/">From X Macro to FOR_EACH to Cartesian Product Enumeration with C Macro</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2022 Haoran Xu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>-->

<script src="../../../../js/bootstrap/bootstrap.min.js"></script>



  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
 

</body>
</html>
