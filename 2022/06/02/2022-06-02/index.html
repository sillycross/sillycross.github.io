<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Understanding GC in JSC From Scratch | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Javascript relies on garbage collection (GC) to reclaim memory. In this post, we will dig a little bit into JSC (the Javascript engine of WebKit)&#39;s garbage collection system. WebKit’s blog post on GC">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding GC in JSC From Scratch">
<meta property="og:url" content="https://sillycross.github.io/2022/06/02/2022-06-02/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Javascript relies on garbage collection (GC) to reclaim memory. In this post, we will dig a little bit into JSC (the Javascript engine of WebKit)&#39;s garbage collection system. WebKit’s blog post on GC">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-02T00:00:00.000Z">
<meta property="article:modified_time" content="2023-05-08T07:31:55.239Z">
<meta property="article:author" content="Haoran Xu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../../../../atom.xml" title="" type="application/atom+xml">
  
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
    <!--
<link rel="stylesheet" href="../../../../css/source_code_pro.css">
-->
    <link rel="stylesheet" href="../css/source_code_pro.css?ver=20230504">
  

  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">-->
<!--  
<link rel="stylesheet" href="../../../../css/bootstrap/bootstrap.min.css">
 -->

<link rel="stylesheet" href="../css/bootstrap/bootstrap.min.css?ver=20230504">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

<link rel="stylesheet" href="../css/styles.css?ver=20230504">

<!--  
<link rel="stylesheet" href="../../../../css/styles.css">
 -->

  

  
  <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->
  
<script src="../../../../js/jquery.min.js"></script>


<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="../../../../index.html">Home</a></li>
        
          <li><a class=""
                 href="../../../../archives/">Archives</a></li>
        
          <li><a class=""
                 href="../../../../about/">About</a></li>
        
          <li><a class=""
                 href="../../../../cnblog/">Chinese Blog</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title"></h1>
  
    <p class="blog-description">「こんなきれいな星も、やっぱりここまで来てから、見れたのだと思うから。だから・・もっと遠くへ・・」</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-2022-06-02" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Understanding GC in JSC From Scratch
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="" class="article-date"><time datetime="2022-06-02T00:00:00.000Z" itemprop="datePublished">2022-06-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Javascript relies on garbage collection (GC) to reclaim memory. In this post, we will dig a little bit into JSC (the Javascript engine of <a href="https://webkit.org/" target="_blank" rel="noopener">WebKit</a>)'s garbage collection system.</p>
<p>WebKit’s <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/" target="_blank" rel="noopener">blog post on GC</a> is a great post that explained the novelties of JSC’s GC and also positioned it within the context of various GC schemes in academia and industry. However, as someone with little GC background, I found WebKit’s blog post too hard to understand, and also too vague to understand the specific design used by JSC. So this blog post attempts to add in some more details, and aims to be understandable even by someone with little prior background on GC.</p>
<p>The garbage collector in JSC is <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Moving_vs._non-moving" target="_blank" rel="noopener">non-compacting</a>, <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)" target="_blank" rel="noopener">generational</a> and mostly<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>-<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent" target="_blank" rel="noopener">concurrent</a>. On top of being concurrent, JSC’s GC heavily employs lock-free programming for better performance.</p>
<p>As you can imagine, the design used by JSC is quite complex. So instead of diving into the complex invariants and protocols, we will start with the simplest design, and improve it step by step to converge at JSC’s design in the end. This way, we not only understand <em>why</em> JSC’s design works, but also <em>how</em> JSC’s design is reached.</p>
<p>But first of all, let’s get into some background.</p>
<h3 id="Memory-Allocation-in-JSC">Memory Allocation in JSC</h3>
<p>Memory allocator and GC are tightly coupled by nature – the allocator allocates memory to be reclaimed by the GC, and the GC frees memory to be reused by the allocator. In this section, we will briefly introduce JSC’s memory allocators.</p>
<p>At the core of the memory allocation scheme in JSC is the data structure <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectory.h.html#JSC::BlockDirectory">BlockDirectory</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. It implements a fixed-sized allocator, that is, an allocator that only allocates memory chunks of some fixed size <code>S</code>. The allocator keeps tracks of a list of fixed-sized (in current code, 16KB) memory pages (“blocks”) it owns, and a free list. Each block is divided into cells of size <code>S</code>, and has a footer at its end<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, which contains various metadata information needed for GC and allocator, e.g., which cells are free. By aggregating and sharing metadata at the footer, it both saves memory and improves performance of related operations: we will go into details later.</p>
<p>When a <code>BlockDirectory</code> needs to make an allocation, it tries to allocate from its free list. If the free list is empty, it tries to iterate through the blocks it owns<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, to see if it can find a block containing free cells (which are marked free by GC). If yes, it <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle5sweepEPNS_8FreeListE">scans the block footer metadata</a> to find out all the free cells<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> in this block, and put into the free list. Otherwise, it allocates a new block from the OS<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Note that this implies a <code>BlockDirectory</code>’s free list only contains cells in one block: this is called <code>m_currentBlock</code> in the code, and we will revisit this later.</p>
<p>The <code>BlockDirectory</code> is used as the building block to build the memory allocators in JSC. JSC employs three kinds of allocators:</p>
<ol>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/CompleteSubspace.h.html#32">CompleteSubspace</a>: this is a segregated allocator responsible for allocating small objects (max size about 8KB). Specifically, there is a pre-defined list of exponentially-growing size-classes<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>, and one <code>BlockDirectory</code> is used to handle allocation for each size class. So to allocate an object, you find the smallest size class large enough to hold the object, and allocate from that size class.</li>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation">PreciseAllocation</a>: this is used to handle large allocations that cannot be handled by <code>CompleteSubspace</code> allocator<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>. It simply relies on the standard (malloc-like) memory allocator, though in JSC a custom malloc implementation called <code>libpas</code> is used. The downside is that since <code>PreciseAllocation</code> is done on a per-object basis, it cannot aggregate and share metadata information of multiple objects together to save memory and improve performance (as <code>CompleteSubspace</code>’s block footer did). Therefore, every <code>PreciseAllocation</code> comes with a whopping overhead of a <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation">96-byte GC header</a> to store the various metadata information needed for GC for this object (though this overhead is justified since each allocation is already at least 8KB).</li>
<li><a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/IsoSubspace.h.html#JSC::IsoSubspace">IsoSubspace</a>: each <code>IsoSubspace</code> is used to allocate objects of a fixed type with a fixed size. So each <code>IsoSubspace</code> simply holds a <code>BlockDirectory</code> to do allocation (though JSC also has an optimization for small <code>IsoSubspace</code> by making them backed by <code>PreciseAllocation</code><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>). This is mainly a security hardening feature that makes use-after-free-based attacks harder<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>.</li>
</ol>
<p>As you can see, <code>IsoSubspace</code> is mostly a simplified <code>CompleteSubspace</code>, so we will ignore it for the purpose of this post. <code>CompleteSubspace</code> is the one that handles the common case: small allocations, and <code>PreciseAllocation</code> is mostly the rare slow path for large allocations.</p>
<h3 id="Generational-GC-Basics">Generational GC Basics</h3>
<p>In JSC’s generational GC model, the heap consists of a small “new space” (eden), holding the newly allocated objects, and a large “old space” holding the older objects that have survived one GC cycle. Each GC cycle is either an <em>eden GC</em> or a <em>full GC</em>. New objects are allocated in the eden. When the eden is full, an eden GC is invoked to garbage-collect the unreachable objects in eden. All the surviving objects in eden are then considered to be in the old space<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>. To reclaim objects in the old space, a full GC is needed.</p>
<p>The effectiveness of the above scheme relies on the so-called “generational hypothesis”:</p>
<ol>
<li>Most objects collected by the GC are young objects (died when they are still in eden), so eden GC (which only collects the eden) is sufficient to reclaim most of the memory.</li>
<li>Pointers from old space to eden is much rarer than pointers from eden to old space or pointers from eden to eden, so an eden GC’s runtime is approximately linear to the size of the eden, as it only needs to start from a small subset of the old space. This implies that the cost of GC can be amortized by the cost of allocation.</li>
</ol>
<h4 id="Inlined-vs-Outlined-Metadata-Why">Inlined vs. Outlined Metadata: Why?</h4>
<p>Practically every GC scheme uses some kind of metadata to track which objects are alive. In this section, we will explain how those metadata are stored in JSC, and the motivation behind such design.</p>
<p>In JSC, every object managed by the GC carries the following metadata:</p>
<ol>
<li>Every object managed by GC inherit the <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/runtime/JSCell.h.html#JSC::JSCell">JSCell</a> class, which contains a 1-byte member <code>cellState</code>. This <code>cellState</code> is a color marker with two colors: white and black<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>.</li>
<li>Every object also has two out-of-object metadata bits: <code>isNew</code><sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup> and <code>isMarked</code>. For objects allocated by <code>PreciseAllocation</code>, the bits reside in the GC header. For objects allocated by <code>CompleteSubspace</code>, the bits reside in the block footer.</li>
</ol>
<p>This may seem odd at first glance since <code>isNew</code> and <code>isMarked</code> could have been stored in the unused bits of <code>cellState</code>. However, this is intentional.</p>
<p>The inlined metadata <code>cellState</code> is easy to access for the mutator thread (the thread executing Javascript code), since it is just a field in the object. However, it has bad memory locality for GC and allocators, which need to quickly traverse through all the metadata of all objects in some block owned by <code>CompleteSubspace</code> (which is the common case). Outlined metadata have the opposite performance characteristics: they are more expensive to access for the mutator thread, but since they are aggregated into bitvectors and stored in the block footer of each block, GC and allocators can traverse them really fast.</p>
<p>So JSC keeps both inlined and outlined metadata to get the better of both worlds: the mutator thread’s fast path will only concern the inlined <code>cellState</code>, while the GC and allocator logic can also take advantage of the memory locality of the outlined bits <code>isNew</code> and <code>isMarked</code>.</p>
<p>Of course, the cost of this is a more complex design… so we have to unfold it bit by bit.</p>
<h3 id="A-Really-Naive-Stop-the-World-Generational-GC">A Really Naive Stop-the-World Generational GC</h3>
<p>Let’s start with a really naive design just to understand what is needed. We will design a generational, but stop-the-world (i.e. not incremental or concurrent) GC, with no performance optimizations at all. In this design, the mutator side transfers control to the GC subsystem at a “safe point”<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> to start a GC cycle (eden or full). The GC subsystem performs the GC cycle from the beginning to the end (as a result, the application cannot run during this potentially long period, thus “stop-the-world”), and then transfer control back to the mutator side.</p>
<p>For this purpose, let’s temporarily forget about <code>CompleteSubspace</code>: it is an optimized version of <code>PrecisionAllocation</code> for small allocations, and while it is an important optimization, it’s easier to understand the GC algorithm without it.</p>
<p>It turns out that in this design, all we need is one <code>isMarked</code> bit. The <code>isMarked</code> bit will indicate if the object is reachable at the end of the last GC cycle (and consequently, is in the old space, since any object that survived a GC cycle is in old space). All objects are born with <code>isMarked = false</code>.</p>
<p>The GC will use a breadth-first search to scan and mark objects. For full GC, we want to reset all <code>isMarked</code> bit to <code>false</code> at the beginnning, and do a BFS to scan and mark all objects reachable from GC roots. Then all the unmarked objects are known to be dead. For eden GC, we only want to scan the eden space. Fortunately, all objects in the old space are already marked at the end of the previous GC cycle, so they are naturally ignored by the BFS, so we can simply reuse the same BFS algorithm in full GC. In pseudo-code:</p>
<p>Eden GC preparation phase: no work is needed.</p>
<p>Full GC preparation phase<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (JSCell* obj : heap) </span><br><span class="line">  obj-&gt;isMarked = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC marking phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">  JSCell* obj = <span class="built_in">queue</span>.pop();</span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      child-&gt;isMarked = <span class="literal">true</span>; </span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC collection phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One can easily imagine optimization to make eden collection </span></span><br><span class="line"><span class="comment">// traverse only the eden space. We ignore it for simplicity.</span></span><br><span class="line"><span class="keyword">for</span> (JSCell* obj : heap) </span><br><span class="line">  <span class="keyword">if</span> (!obj-&gt;isMarked) </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br></pre></td></tr></table></figure>
<p>But where does the scan start, so that we can scan through every reachable object? For full GC, the answer is clear: we just start the scan from all <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Reachability_of_an_object" target="_blank" rel="noopener">GC roots</a><sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>. However, for eden GC, in order to reliably scan through all reachable objects, the situation is slightly more complex:</p>
<ol>
<li>Of course, we still need to push the GC roots to the initial queue.</li>
<li>If an object in the old space contains a pointer to an object in eden, we need to put the old space object to the initial queue<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>.</li>
</ol>
<p>The invariant for the second case is maintained by the mutator side. Specifically, whenever one writes a pointer slot of some object <code>A</code> in the heap to point to another object <code>B</code>, one needs to check if <code>A.isMarked</code> is <code>true</code> and <code>B.isMarked</code> is <code>false</code>. If so, one needs to put <code>A</code> into a “remembered set”. Eden GC must treat the objects in the remembered set as if they were GC roots. This is called a <code>WriteBarrier</code>. In pseudo-code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed after writing a pointer to 'dst' into a field of 'obj'</span></span><br><span class="line"><span class="keyword">if</span> (obj-&gt;isMarked &amp;&amp; !dst-&gt;isMarked) </span><br><span class="line">  addToRememberedSet(obj);</span><br></pre></td></tr></table></figure>
<h3 id="Getting-Incremental">Getting Incremental</h3>
<p>The stop-the-world GC isn’t feasible for production use. A GC cycle (especially a full GC cycle) can take a long time. Since the mutator (application logic) cannot run during the period, the application would appear irresponsive to the user, which is very bad user experience.</p>
<p>A natural way to shorten this irresponsive period is to run GC incrementally: at safe points, the mutator transfers control to the GC. The GC only runs for a short time, doing a portion of the work for the current GC cycle (eden or full), then return control to the mutator. This way, each GC cycle is splitted into many small steps, so the irresponsive periods are less noticeable for the user.</p>
<p>Incremental GC poses a few new challenges to the GC scheme.</p>
<p>The first challenge is the extra interference between GC and mutator: the mutator side, namely the allocator and the <code>WriteBarrier</code>, must be prepared to see states arisen from a partially-completed GC cycle. And the GC side must correctly mark all reachable objects despite changes made by the mutator side in between.</p>
<p>Specifically, our full GC must change: imagine that the full GC scanned some object <code>o</code> and handed back control to mutator, then the mutator changed a field of <code>o</code> to point to some other object <code>dst</code>. The object <code>dst</code> must not be missed from scanning. Fortunately, in such case <code>o</code> will be <code>isMarked</code> and <code>dst</code> will be <code>!isMarked</code> (if <code>dst</code> has <code>isMarked</code> then it has been scanned, so there’s nothing to worry about), so <code>o</code> will be put into the remembered set.</p>
<p>Therefore, for full GC to function correctly in the incremental GC scheme, it must consider the remembered set as GC root as well, just like the eden GC.</p>
<p>The other parts of the algorithm as of now can remain unchanged (we leave the proof of correctness as an excerise for the reader). Nevertheless, “what happens if a GC cycle is run partially?” is something that we must keep in mind as we add more optimizations.</p>
<p>The second challenge is that the mutator side can repeatedly put an old space object into the remembered set, and result in redundant work for the GC: for example, the GC popped some object <code>o</code> in the remembered set, traversed from it, and handed over control to mutator. The mutator modified <code>o</code> again, putting it back to the remembered set. If this happens too often, the incremental GC could do a lot more work than a stop-the-world GC.</p>
<p>The obvious mitigation is to have the GC scan the remembered set last: only when the queue has otherwise been empty do we start popping from the remembered set. However, it turns out that this is not enough. JSC employs a technique called <em>Space-Time Scheduler</em> to further mitigate this problem. In short, if it obverves that the mutator was allocating too fast, the mutator would get decreasingly less time quota to run so the GC can catch up (and in the extreme case, the mutator would get zero time quota to run, so it falls back to the stop-the-world approach). The <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/" target="_blank" rel="noopener">WebKit blog post</a> has explained it very clearly, so feel free to take a look if you are interested.</p>
<p>Anyway, let’s update the pseudo-code for the eden/full GC marking phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty() || !rmbSet.empty()) &#123;</span><br><span class="line">  <span class="comment">// Both eden GC and full GC needs to consider remembered set</span></span><br><span class="line">  <span class="comment">// Prioritize popping from queue, pop remembered set last</span></span><br><span class="line">  JSCell* obj = !<span class="built_in">queue</span>.empty() ? <span class="built_in">queue</span>.pop() : rmbSet.pop();</span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      child-&gt;isMarked = <span class="literal">true</span>; </span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Incorporate-in-CompleteSubspace">Incorporate in CompleteSubspace</h3>
<p>It’s time to get our <code>CompleteSubspace</code> allocator back so we don’t have to suffer the huge per-object GC header overhead incurred by <code>PreciseAllocation</code>.</p>
<p>For <code>PreciseAllocation</code>, the actual memory management work is done by <code>malloc</code>: when the mutator wants to allocate an object, it just <code>malloc</code> it, and when the GC discovers a dead object, it just <code>free</code> it.</p>
<p><code>CompleteSubspace</code> introduces another complexity, as it only allocate/deallocate memory from the OS at 16KB-block level, and does memory management itself to divide the blocks into cells that it serves to the application. Therefore, it has to track whether each of its cells is available for allocation. The mutator allocates from the available cells, and the GC marks dead cells as available for allocation again.</p>
<p>The <code>isMarked</code> bit is not enough for the <code>CompleteSubspace</code> allocator to determine if a cell contains a live object or not: newly allocated objects have <code>isMarked = false</code> but are clearly live objects. Therefore, we need another bit.</p>
<p>In fact, there are other good reasons that we need to support checking if a cell contains a live object or not. A canonical example is the conservative stack scanning: JSC cannot precisely understand the layout of the stack, so it needs to treat everything on the stack that could be pointers and pointing to live objects as GC root, and this involves checking if a heap pointer points to a live object or not.</p>
<p>One can easily imagine some kind of <code>isLive</code> bit that is <code>true</code> for all live objects, which is only flipped to <code>false</code> by GC when the object is dead. However, JSC employed a slightly different scheme, which is needed to facilitate optimizations that we will mention later.</p>
<p>As you have seen earlier, the bit used by JSC is called <code>isNew</code>.</p>
<p><a name="purposeOfIsNewBit"></a>However, keep in mind: you should <strong>not</strong> think of <code>isNew</code> as a bit that tells you <strong>anything</strong> related to its name, or indicates anything by itself. You should think of it as a helper bit, which sole purpose is that, when working togther with <code>isMarked</code>, they tell you if a cell contains a live object or not. This thinking mode will be more important in the next section when we introduce logical versioning.</p>
<p>The core invariant around <code>isNew</code> and <code>isMarked</code> is:</p>
<ol>
<li>At <strong>any</strong> moment, an object is dead iff its <code>isNew = false</code> and <code>isMarked = false</code>.</li>
</ol>
<p>If we were a stop-the-world GC, then to maintain this invariant, we only need the following:</p>
<ol>
<li>When an object is born, it has <code>isNew = true</code> and <code>isMarked = false</code>.</li>
<li>At the end of each eden or full GC cycle, we set <code>isNew</code> of all objects to <code>false</code>.</li>
</ol>
<p>Then, all newly-allocated objects are live because its <code>isNew</code> is <code>true</code>. At the end of each GC cycle, an object is live iff its <code>isMarked</code> is <code>true</code>, so after we set <code>isNew</code> to <code>false</code> (due to rule 2), the invariant on dead object is maintained, as desired.</p>
<p>However, in an incremental GC, since the state of a partially-run GC cycle can be exposed to mutator, we need to be careful that the invariant holds in this case as well.</p>
<p>Specifically, in full GC, we reset all <code>isMarked</code> to <code>false</code> at the beginning. Then, during a partially-run GC cycle, the mutator may see a live object with both <code>isMarked = false</code> (beacuse it has not been marked by GC yet), and <code>isNew = false</code> (because it has survived one prior GC cycle). This violates our invariant.</p>
<p>To fix this, at the beginning of a full GC, we additionally do <code>isNew |= isMarked</code> before clearing <code>isMarked</code>. Now, during the whole full GC cycle, all live objects must have <code>isNew = true</code><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>, so our invariant is maintained. At the end of the cycle, all <code>isNew</code> bits are cleared, and as a result, all the unmarked objects become dead, so our invariant is still maintained as desired. So let’s update our pseudo-code:</p>
<p>Eden GC preparation phase: no work is needed.</p>
<p>Full GC preparation phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do 'isNew |= isMarked, isMarked = false' for all </span></span><br><span class="line"><span class="comment">// PreciseAllocation and all cells in CompleteSubspace</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew |= pa-&gt;isMarked;</span><br><span class="line">  pa-&gt;isMarked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BlockFooter* block : allCompleteSubspaceBlocks) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">    block-&gt;isNew[cellId] |= block-&gt;isMarked[cellId];</span><br><span class="line">    block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC collection phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update 'isNew = false' for CompleteSubspace cells </span></span><br><span class="line"><span class="keyword">for</span> (BlockFooter* block : allCompleteSubspaceBlocks) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">    block-&gt;isNew[cellId] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For PreciseAllocation, in addition to updating 'isNew = false',</span></span><br><span class="line"><span class="comment">// we also need to free the dead objects</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!pa-&gt;isMarked) </span><br><span class="line">    <span class="built_in">free</span>(pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In <code>CompleteSubspace</code> allocator, to check if a cell in a block contains a live object (if not, then the cell is available for allocation):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cellContainsLiveObject</span><span class="params">(BlockFooter* block, <span class="keyword">size_t</span> cellId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> block-&gt;isMarked[cellId] || block-&gt;isNew[cellId];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Logical-Versioning-Do-Not-Sweep">Logical Versioning: Do Not Sweep!</h3>
<p>We are doing a lot of work at the beginning of a full GC cycle and at the end of any GC cycle, since we have to iterate through all the blocks in <code>CompleteSubspace</code> and update their <code>isMarked</code> and <code>isNew</code> bits. Despite that the bits in one block are clustered into bitvectors thus have good memory locality, this could still be an expensive operation, especially after we have a concurrent GC (as this stage cannot be made concurrent). So we want something better.</p>
<p>The optimization JSC employs is logical versioning. Instead of physically clearing all bits in all blocks for every GC cycle, we only bump a global “logical version”, indicating that all the bits are logically cleared (or updated). Only when we actually need to mark a cell in a block during the marking phase do we then physically clear (or update) the bitvectors in this block.</p>
<p>You may ask: why bother with logical versioning, if in the future we still have to update the bitvectors physically anyway? There are two good reasons:</p>
<ol>
<li>If all cells in a block are dead (either died out during this GC cycle<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>, or already dead before this GC cycle), then we will never mark anything in the block, so logical versioning enabled us to avoid the work altogether. This also implies that at the end of each GC cycle, it’s unnecessary to figure out which blocks become completely empty, as logical versioning makes sure that these empty blocks will not cause overhead to future GC cycles.</li>
<li>The marking phase can be done concurrently with multiple threads <em>and</em> while the mutator thread is running (our scheme isn’t concurrent now, but we will do it soon), while the preparation / collection phase must be performed single-threadedly <em>and</em> with the mutator stopped. Therefore, shifting the work to marking phase reduces GC latency in a concurrent setting.</li>
</ol>
<p>There are two global version number <code>g_markVersion</code> and <code>g_newVersion</code><sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>. Each block footer also stores its local version number <code>l_markVersion</code> and <code>l_newVersion</code>.</p>
<p>Let’s start with the easier case: the logical versioning for the <code>isNew</code> bit.</p>
<p>If you revisit the pseudo-code above, in GC there is only one place where we write <code>isNew</code>: at the end of each GC cycle, we set all the <code>isNew</code> bits to <code>false</code>. Therefore, we simply <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedSpace.cpp.html#446">bump</a> <code>g_newVersion</code> there instead. A local version <code>l_newVersion</code> smaller than <code>g_newVersion</code> means that all the <code>isNew</code> bits in this block have been logically cleared to <code>false</code>.</p>
<p>When the <code>CompleteSubspace</code> allocator allocates a new object, it needs to start with <code>isNew = true</code>. One can clearly do this directly, but JSC did it in a trickier way that involves a block-level bit named <code>allocated</code> for slightly better performance. This is not too interesting, so I deferred it to <a href="#isNewAndAllocateBit">the end of the post</a>, and our scheme described here right now will not employ this optimization (but is otherwise intentionally kept semantically equivalent as JSC):</p>
<ol>
<li>When a <code>BlockDirectory</code> starts allocating from a new block, it update the the block’s <code>l_newVersion</code> to <code>g_newVersion</code>, and set <code>isNew</code> to <code>true</code> for all already-allocated cells (as the block may not be fully empty), and <code>false</code> for all available cells.</li>
<li>Whenever it allocates a cell, it sets its <code>isNew</code> to true.</li>
</ol>
<p>Why do we want to bother setting <code>isNew</code> to <code>true</code> for all already-allocated cells in the block? This is to provide a good property. Since we bump <code>g_newVersion</code> at the end of every GC cycle, due to the scheme above, for any block with latest <code>l_newVersion</code>, a cell is live if and only if its <code>isNew</code> bit is set. Now, when checking if a cell is live, if its <code>l_newVersion</code> is latest, then we can just return <code>isNew</code> without looking at <code>isMarked</code>, so our logic is simpler.</p>
<p>The logical versioning for the <code>isMarked</code> bit is similar. At the beginning of a full GC cycle, we bump the <code>g_markVersion</code> to indicate that all mark bits are logically cleared. Note that the global version is not bumped for eden GC, since eden GC does not clear <code>isMark</code> bits.</p>
<p>There is one extra complexity: the above scheme would break down in incremental GC. Specifically, <em>during</em> a full GC cycle, we have logically cleared the <code>isMarked</code> bit, but we also didn’t do anything to the <code>isNew</code> bit, so all cells in the old space would appear dead to the allocator. In our old scheme without logical versioning, this case is prevented by doing <code>isNew |= isMarked</code> at the start of the full GC, but we cannot do it now with logical versioning.</p>
<p>JSC solves this problem with the following clever trick: <em>during</em> a full GC, we should also accept <code>l_markVersion</code> that is off-by-one. In that case, we know the <code>isMarked</code> bit accurately reflect whether or not a cell is live, since that is the result of the last GC cycle. If you are a bit confused, take a look at footnote<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup> for a more elaborated case discussion. It might also help to take a look at the comments in the pseudo-code below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cellContainsLiveObject</span><span class="params">(BlockFooter* block, <span class="keyword">size_t</span> cellId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (block-&gt;l_newVersion == g_newVersion) &#123;</span><br><span class="line">    <span class="comment">// A latest l_newVersion indicates that the cell is live if</span></span><br><span class="line">    <span class="comment">// and only if its 'isNew' bit is set, so we don't need to</span></span><br><span class="line">    <span class="comment">// look at the 'isMarked' bit even if 'isNew' is false</span></span><br><span class="line">    <span class="keyword">return</span> block-&gt;isNew[cellId];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Now we know isNew bit is logically false, so we should</span></span><br><span class="line">  <span class="comment">// look at the isMarked bit to determine if the object is live</span></span><br><span class="line">  <span class="keyword">if</span> (isMarkBitLogicallyCleared(block)) &#123;</span><br><span class="line">    <span class="comment">// The isMarked bit is logically false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// The isMarked bit is valid and accurately tells us if </span></span><br><span class="line">  <span class="comment">// the object is live or not</span></span><br><span class="line">  <span class="keyword">return</span> block-&gt;isMarked[cellId];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if the isMarked bitvector is logically cleared</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMarkBitLogicallyCleared</span><span class="params">(BlockFooter* block)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (block-&gt;l_markVersion == g_markVersion) &#123;</span><br><span class="line">    <span class="comment">// The mark version is up-to-date, so not cleared</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IsFullGcRunning() &amp;&amp; IsGcInMarkingPhase() &amp;&amp; </span><br><span class="line">      block-&gt;l_markVersion == g_markVersion - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// We are halfway inside a full GC cycle's marking phase,</span></span><br><span class="line">    <span class="comment">// and the mark version is off-by-one, so the isMarked bit</span></span><br><span class="line">    <span class="comment">// should be accepted, and it accurately tells us if the </span></span><br><span class="line">    <span class="comment">// object is live or not</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Before we mark an object in <code>CompleteSubspace</code>, we need to update the <code>l_markVersion</code> of the block holding the cell to latest, and materialize the <code>isMarked</code> bits of all cells in the block. That is, we need to run the logic at the full GC preparation phase in our old scheme: <code>isNew |= isMarked</code>, <code>isMarked = false</code> for all cells in the block. This is shown below.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Used by GC marking phase to mark an object in CompleteSubspace</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markObject</span><span class="params">(BlockFooter* block, <span class="keyword">size_t</span> cellId)</span> </span>&#123;</span><br><span class="line">  aboutToMark(block);</span><br><span class="line">  block-&gt;isMarked[cellId] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Materialize 'isMarked' bits if needed</span></span><br><span class="line"><span class="comment">// To do this, we need to execute the operation at full GC </span></span><br><span class="line"><span class="comment">// prepare phase: isNew |= isMarked, isMarked = false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aboutToMark</span><span class="params">(BlockFooter* block)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (block-&gt;l_markVersion == g_markVersion) &#123;</span><br><span class="line">    <span class="comment">// Our mark version is already up-to-date,</span></span><br><span class="line">    <span class="comment">// which means it has been materialized before</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check if the isMarked bit is logically cleared to false.</span></span><br><span class="line">  <span class="comment">// The function is defined in the previous snippet.</span></span><br><span class="line">  <span class="keyword">if</span> (isMarkBitLogicallyCleared(block)) &#123;</span><br><span class="line">    <span class="comment">// This means that the isMarked bitvector should </span></span><br><span class="line">    <span class="comment">// be treated as all false. So operation isNew |= isMarked </span></span><br><span class="line">    <span class="comment">// is no-op, so all we need to do is isMarked = false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">      block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The 'isMarked' bit is not logically cleared. Now let's </span></span><br><span class="line">    <span class="comment">// check if the 'isNew' bit is logically cleared.</span></span><br><span class="line">    <span class="keyword">if</span> (block-&gt;l_newVersion &lt; g_newVersion) &#123;</span><br><span class="line">      <span class="comment">// The isNew bitvector is logically cleared and should be </span></span><br><span class="line">      <span class="comment">// treated as false. So operation isNew |= isMarked becomes</span></span><br><span class="line">      <span class="comment">// isNew = isMarked (note that executing |= is incorrect </span></span><br><span class="line">      <span class="comment">// beacuse isNew could physically contain true!)</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">        block-&gt;isNew[cellId] = block-&gt;isMarked[cellId];</span><br><span class="line">        block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// We materialized isNew, so update it to latest version</span></span><br><span class="line">      block-&gt;l_newVersion = g_newVersion;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// The l_newVersion is latest, which means that the cell is </span></span><br><span class="line">      <span class="comment">// live if and only if its isNew bit is set. </span></span><br><span class="line">      <span class="comment">// Since isNew already reflects liveness, we do not have to</span></span><br><span class="line">      <span class="comment">// perform the operation isNew |= isMarked (and in fact, it </span></span><br><span class="line">      <span class="comment">// must be a no-op since no dead cell can have isMarked = </span></span><br><span class="line">      <span class="comment">// true). So we only need to do isMarked = false</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">size_t</span> cellId = <span class="number">0</span>; cellId &lt; block-&gt;numCells; cellId++) &#123;</span><br><span class="line">        block-&gt;isMarked[cellId] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We finished materializing isMarked, so update the version</span></span><br><span class="line">  block-&gt;l_markVersion = g_markVersion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A fun fact: despite that what we conceptually want to do above is <code>isNew |= isMarked</code>, the above code never performs a <code>|=</code> at all :)</p>
<p>And also, let’s update the pseudo-code for relavent GC logic:</p>
<p>Eden GC preparation phase: no work is needed.</p>
<p>Full GC preparation phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For PreciseAllocation, we still need to manually do </span></span><br><span class="line"><span class="comment">// 'isNew |= isMarked, isMarked = false' for every allocation</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew |= pa-&gt;isMarked;</span><br><span class="line">  pa-&gt;isMarked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For CompleteSubspace, all we need to do is bumping the </span></span><br><span class="line"><span class="comment">// global version for 'isMarked' bit</span></span><br><span class="line">g_markVersion++;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC collection phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For PreciseAllocation, we still need to manually </span></span><br><span class="line"><span class="comment">// update 'isNew = false' for each allocation, and also</span></span><br><span class="line"><span class="comment">// free the object if it is dead</span></span><br><span class="line"><span class="keyword">for</span> (PreciseAllocation* pa : allPreciseAllocations) &#123;</span><br><span class="line">  pa-&gt;isNew = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!pa-&gt;isMarked) </span><br><span class="line">    <span class="built_in">free</span>(pa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For CompleteSubspace, all we need to do is bumping the</span></span><br><span class="line"><span class="comment">// global version for 'isNew' bit</span></span><br><span class="line">g_newVersion++;</span><br></pre></td></tr></table></figure>
<p>With logical versioning, GC no longer sweeps the <code>CompleteSubspace</code> blocks to reclaim dead objects: the reclamation happens lazily, when the allocator starts to allocate from the block. This, however, introduces an unwanted side-effect. Some objects use manual memory management internally: they own additional memory that are not managed by GC, and have C++ destructors to free those memory when the object is dead. This improves performance as it reduces the work of GC. However, now we do not immediately sweep dead objects and run destructor, so the memory that are supposed to be freed by the destructor could be kept around indefinitely longer, if the block is never allocated from. To mitigate this issue, JSC will also periodically sweep the blocks and run the destructors of the dead objects. This is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/IncrementalSweeper.h.html#JSC::IncrementalSweeper">implemented</a> by <code>IncrementalSweeper</code>, but we will not go into details.</p>
<p>To conclude, logical versioning provided two important optimizations to the GC scheme:</p>
<ol>
<li>The so-called “sweep” phase of the GC (to find out and reclaim dead objects) is removed for <code>CompleteSubspace</code> objects. The reclamation is done lazily. This is clearly better than sweeping through the block again and again in every GC cycle.</li>
<li>The full GC does not need to reset all <code>isMarked</code> bit in the preparation phase, but only lazily reset them in the marking phase by <code>aboutToMark</code>: this not only reduces work, but also allows the work to be done parallelized and while the mutator is running, after we make our GC scheme concurrent.</li>
</ol>
<h3 id="Optimizing-WriteBarrier-The-cellState-Bit">Optimizing WriteBarrier: The cellState Bit</h3>
<p>As we have explained earlier, whenever the mutator modified a pointer of a marked object <code>o</code> to point to an unmarked object, it needs to add <code>o</code> to the “remembered set”, and this is called the <code>WriteBarrier</code>. In this section, we will dig a bit deeper into the <code>WriteBarrier</code> and explain the optimizations around it.</p>
<p>The first problem with our current <code>WriteBarrier</code> is that the <code>isMarked</code> bit resides in the block footer, so retrieving its value requires quite a few computations from the object pointer. Also it doesn’t sit in the same CPU cache line as the object, which makes the access even slower. This is undesirable as the cost is paid for every <code>WriteBarrier</code>, no matter if we actually added the object to remembered set in the end or not.</p>
<p>The second problem is, our <code>WriteBarrier</code> will repeatedly add the same object <code>o</code> to the remembered set every time it is run. The obvious solution is to make <code>rememberedSet</code> a hash set to de-duplicate the objects it contains, but doing a hash lookup to check if the object already exists is still too expensive.</p>
<p>This is where the last metadata bit that we haven’t explained yet: the <code>cellState</code> bit comes in, which solves both problems.</p>
<p>Instead of making <code>rememberedSet</code> a hash table, we reserve a byte (though we only use 1 bit of it) named <code>cellState</code> in every object’s object header, to indicate if we might need to put the object into the remembered set in a <code>WriteBarrier</code>. Since this bit resides in the object header as an object field (instead of in the block footer), it’s trivially accessible to the mutator who has the object pointer.</p>
<p><code>cellState</code> has two possible values: <code>black</code> and <code>white</code>. The most important two invariants around <code>cellState</code> are the following:</p>
<ol>
<li>For any object with <code>cellState = white</code>, it is guaranteed that the object does not need to be added to remembered set.</li>
<li>Unless <em>during</em> a full GC cycle, all <code>black</code> (live) objects have <code>isMarked = true</code>.</li>
</ol>
<p>Invariant 1 serves as a fast-path: <code>WriteBarrier</code> can return immediately if our object is <code>white</code>, and checking it only requires one load instruction (to load <code>cellState</code>) and one comparison instruction to validate it is <code>white</code>.</p>
<p>However, if the object is <code>black</code>, a slow-path is needed to check whether it is actually needed to add the object to remembered set.</p>
<p>Let’s look at our new <code>WriteBarrier</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed after writing a pointer to 'dst' into a field of 'obj'</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrier</span><span class="params">(JSCell* obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj-&gt;cellState == black) </span><br><span class="line">    WriteBarrierSlowPath(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first thing to notice is that the <code>WriteBarrier</code> is no longer checking if <code>dst</code> (the object that the pointer points to) is marked or not. Clearly this does not affect the correctness: we are just making the criteria less restrictive. However, it is unclear to me if we can improve performance while maintaining correctness by making some kind of check on <code>dst</code> as well, like the original <code>WriteBarrier</code> did.</p>
<p>I wasn’t able to get a definite answer on this even from JSC developer. They have two <em>conjectures</em> on why they are doing this: first, by not checking <code>dst</code>, more objects are put into the remembered set and need to be scanned by GC, so the total amount of work increased. However, the mutator’s work probably decreased, as it does less checks and touches less cache lines (by not touching the outlined <code>isMarked</code> bit). Of course, the benefit is offsetted by that the mutator is adding more objects into the remembered set, but this isn’t too expensive either, as the remembered set is only a segmented vector. GC has to do more work, as it needs to scan and mark more objects. However, after we make our scheme concurrent, the marking phase of GC can be done concurrently as the mutator is running, so the latency is probably<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup> hidden. Second, JSC’s DFG compiler has <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGStoreBarrierInsertionPhase.cpp.html">optimization pass</a> that coalesces barriers on the same object together, and the barrier emitted this way naturally cannot check <code>dst</code>. Therefore, to make things easier, they simply made all the barriers to not check <code>dst</code>. Although these are all conjectures, and it is unclear if adding back the <code>dst</code> check can improve performance, this is how JSC works, so let’s stick to it.</p>
<p>The interesting part is how the invariants above are maintained by the relavent parties. As always, there are three actors: the mutator (<code>WriteBarrier</code>), the allocator, and the GC.</p>
<p>The interaction with the allocator is the simplest. All objects are born <code>white</code>. This is correct because newly-born objects are not marked, so have no reason to be remembered.</p>
<p>The interaction with GC is during the GC marking phase:</p>
<ol>
<li>When we mark an object and push it into the queue, we set its <code>cellState</code> to <code>white</code>.</li>
<li>When we pop an object from the queue, before we start to scan its children, we set its <code>cellState</code> to <code>black</code>.</li>
</ol>
<p>In pseudo-code, the Eden/Full GC marking phase now looks like the following (Line 5 and Line 9 are the newly-added logic to handle <code>cellState</code>, other lines unchanged):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty() || !rmbSet.empty()) &#123;</span><br><span class="line">  <span class="comment">// Both eden GC and full GC needs to consider remembered set</span></span><br><span class="line">  <span class="comment">// Prioritize popping from queue, pop remembered set last</span></span><br><span class="line">  JSCell* obj = !<span class="built_in">queue</span>.empty() ? <span class="built_in">queue</span>.pop() : rmbSet.pop();</span><br><span class="line">  obj-&gt;cellState = black;       <span class="comment">// &lt;----------------- newly added</span></span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      markObject(child);</span><br><span class="line">      child-&gt;cellState = white; <span class="comment">// &lt;----------------- newly added</span></span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s argue why the invariant is maintained by the above code.</p>
<ol>
<li>For invariant 1, note that in the above code, an object is <code>white</code> only if it is inside the queue (as once it’s popped out, it becomes <code>black</code> again), pending scanning of its children. Therefore, it is guaranteed that the object will still be scanned by the GC later, so we don’t need to add the object to remembered set, as desired.</li>
<li>For invariant 2, at the end of any GC cycle, any live object is marked, which means it has been scanned, so it is <code>black</code>, as desired.</li>
</ol>
<p>Now let’s look at what <code>WriteBarrierSlowPath</code> should do. Clearly, it’s correct if it simply unconditionally add the object to remembered set, but that also defeats most of the purpose of <code>cellState</code> as an optimization mechanism: we want something better.</p>
<p>A top business of <code>cellState</code> is to prevent adding an object into the remembered set if it is already there. Therefore, after we put the object into the remembered set, we will set its <code>cellState</code> to <code>white</code>, like shown below.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrierSlowPath</span><span class="params">(JSCell* obj)</span> </span>&#123; </span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  addToRememberedSet(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s prove why the above code works. Once we added an object to remembered set, we set it to <code>white</code>. We don’t need to add the same object into the remembered set until it gets popped out from the set by GC. But when GC pops out the object, it would set its <code>cellState</code> back to <code>black</code>, so we are good.</p>
<p>JSC employed one more optimization. During a full GC, we might see <code>black</code> objects that has <code>isMarked = false</code> (note that this is the only possible case that the object is unmarked, due to invariant 2). In this case, it’s unnecessary to add the object to remembered set, since the object will eventually be scanned in the future (or it becomes dead some time later before it was scanned, in which case we are good as well). Furthermore, we can flip it back to <code>white</code>, so we don’t have to go into this slow path the next time a <code>WriteBarrier</code> on this object runs. To sum up, the optimized version is as below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrierSlowPath</span><span class="params">(JSCell* obj)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (IsFullGcRunning()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMarked(obj)) &#123;</span><br><span class="line">      <span class="comment">// Do not add the object to remembered set</span></span><br><span class="line">      <span class="comment">// In addition, set cellState to white so this </span></span><br><span class="line">      <span class="comment">// slow path is not triggered on the next run</span></span><br><span class="line">      obj-&gt;cellState = white;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(isMarked(obj));    <span class="comment">// due to invariant 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  addToRememberedSet(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Getting-Concurrent-and-Getting-Wild">Getting Concurrent and Getting Wild</h3>
<p>At this point, we already have a very good incremental and generational garbage collector: the mutator, allocator and GC all have their respective fast-paths for the common cases, and with logical versioning, we avoided redundant work as much as possible. In my humble opinion, this is a good balance point between performance and engineering complexity.</p>
<p>However, obviously, “engineering complexity” is not a word inside JSC’s dictionary: after all, they have the most talented engineers, to the point that they even <a href="https://webkit.org/blog/5852/introducing-the-b3-jit-compiler/" target="_blank" rel="noopener">engineered their own purpose-built LLVM from scratch</a>!</p>
<p>To squeeze out every bit of performance, JSC proceeded to make the GC scheme concurrent. However, due to the nature of GC, it’s often infeasible to use locks to protect against race conditions for performance reasons, so extensive lock-free programming is employed.</p>
<p>But once lock-free programming is involved, one starts to get into all sorts of architecture-dependent memory reordering problems. x86-64 is the more sane architecture: it only requires <code>StoreLoadFence()</code>, and it provides somewhat-TSO-like semantics, but JSC also needs ARM64 support for their Apple Sillicon devices. ARM64 has even fewer guarantees: load-load, load-store, store-load, and store-store can all be reordered by the CPU, so any innocent operation could actually need a fence. As if things were not bad enough, for performance reasons, JSC does not want to use too many memory fences on ARM64. So they have the so-called <code>Dependency</code> <a href="https://sillycross.github.io/r/WebKit/Source/WTF/wtf/Atomics.h.html#_ZN3WTF10DependencyC1Ev">class</a>, which creates an implicit CPU data dependency on ARM64 through some scary assembly hacks, so they can get the desired memory ordering for a specific data-flow without paying the cost of a memory fence. As you can imagine, with all of these complications and optimizations, the code can easily become horrifying.</p>
<p>So due to my limited expertise, it’s unsurprising if I missed to explain or mis-explained some important race conditions in the code, especially some ARM64-specific ones: if you spotted any issue in this post, please definitely let me know.</p>
<p>Let’s go through the concurrency assumptions first. Javascript is a single-threaded language, so there is always only one mutator thread<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>. Apart from the mutator thread, JSC has a bunch of compilation threads, a GC thread, and a bunch of marking threads. Only the GC marking phase is concurrent: during which the mutator thread, the compiler threads, and a bunch of marking threads are concurrently running (yes, the marking itself is also done in parallel). However, all the other GC phases are run with the mutator thread and compilation threads stopped.</p>
<h4 id="Some-Less-Interesting-Issues">Some Less Interesting Issues</h4>
<p>First of all, clearly the <code>isMarked</code> and <code>isNew</code> bitvector must be made safe for concurrent access, since multiple threads (including marking threads and mutator) may concurrently update it. Using CAS with appropriate retry/bail mechanism is enough for the bitvector itself.</p>
<p><code>BlockFooter</code> is harder, and needs to be protected with a lock: multiple threads could be simutanuously calling <code>aboutToMark()</code>, so <code>aboutToMark()</code> must be guarded. For the reader side (the <code>isMarked()</code> function, which involves first checking if <code>l_markVersion</code> is latest, then reading the <code>isMarked</code> bitvector), in x86-64 thanks to x86-TSO, one does not need a lock or any memory fence (as long as <code>aboutToMark</code> takes care to update <code>l_markVersion</code> after the bitvector). In ARM64, since load-load reordering is allowed, a <code>Dependency</code> is required.</p>
<p>Making the <code>cellContainsLiveObject</code> (or in JSC jargon, <code>isLive</code>) check lock-free is harder, since it involves potentially reading both the <code>isMarked</code> bit and the <code>isNew</code> bit. JSC <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlockInlines.h.html#_ZN3JSC11MarkedBlock6Handle6isLiveEjjbPKNS_8HeapCellE">employs optimistic locking</a> to provide a fast-path. This is not very different from an optimistic locking scheme you can find in a textbook, so I won’t dive into the details.</p>
<p>Of course, there are a lot more subtle issues to change. Almost all the pseudo-code above needs to be adapted for concurrency, either by using a lock or CAS, or by using some sort of memory barriers and concurrency protocol to ensure that the code works correctly under concurrency settings. But now let’s turn to some more important and tricky issues.</p>
<h4 id="The-Race-Between-WriteBarrier-and-Marking">The Race Between WriteBarrier and Marking</h4>
<p>One of the most important race is the race between <code>WriteBarrier</code> and GC’s marking threads. The marking threads and the mutator thread can access the <code>cellState</code> of an object concurrently. For performance reasons, a lock is infeasible, so race condition arises.</p>
<p>It’s important to note that we call <code>WriteBarrier</code> <strong>after</strong> we have written the pointer into the object. This is not only more convenient to use (especially for JIT-generated code), but also allows a few optimizations: for example, <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/dfg/DFGStoreBarrierInsertionPhase.cpp.html">in certain cases</a>, multiple writes to the same object may only call <code>WriteBarrier</code> once at the end.</p>
<p>With this in mind, let’s analyze why our current implementation is buggy. Suppose <code>o</code> is an object, and the mutator wants to store a pointer to another object <code>target</code> into a field <code>f</code> of <code>o</code>. The marking logic of GC wants to scan <code>o</code> and append its children into the queue. We need to make sure that GC will observe the <code>o -&gt; target</code> pointer link.</p>
<p>Let’s first look at the correct logic:</p>
<div>
<div style="float:left; width:50%; border-right: solid 1px; border-bottom: solid 1px; background-color:#FFCB9A">
<div style="margin-left:10px; ">
Mutator (WriteBarrier)
</div>
</div>
<div style="float:left; width:50%; border-bottom: solid 1px; background-color:#A8B545">
<div style="margin-left:10px;">
GC (Marker) 
</div>
</div>
</div>
<div>
<div style="float:left; width:50%; border-right: solid 1px;">
<div style="margin-left:10px; ">
Store(o.f, target)<br>
StoreLoadFence()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// WriteBarrier begin<br>                               
t1 = Load(o.cellState)<br>
if (t1 == black): WriteBarrierSlowPath(o)
</div>
</div>
<div style="float:left; width:50%;">
<div style="margin-left:10px;">
Store(o.cellState, black)<br>
StoreLoadFence()<br>
t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load a children of o<br>
Do some check to t2 and push it to queue<br>
</div>
</div>
</div>
<div style="display: table; clear: both;"</div>
<br>
<p>This is mostly just a copy of the pseudocode in the above sections, except that we have two <code>StoreLoadFence()</code>. A <code>StoreLoadFence()</code> guarantees that no <code>LOAD</code> after the fence may be executed by the CPU out-of-order engine until all <code>STORE</code> before the fence have completed. Let’s first analyze what could go wrong without either of the fences.</p>
<p>Just to make things perfectly clear, the precondition is <code>o.cellState = white</code> (because <code>o</code> is in the GC’s queue) and <code>o.f = someOldValue</code>.</p>
<p>What could go wrong if the mutator <code>WriteBarrier</code> doesn’t have the fence? Without the fence, the CPU can execute the <code>LOAD</code> in line 3 before the <code>STORE</code> in line 1. Then, in the following interleaving:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = white</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
</ol>
<p>Now, the mutator did not add <code>o</code> to remembered set (because <code>t1</code> is <code>white</code>, not <code>black</code>), and <code>t2</code> in GC is the old value in <code>o.f</code> instead of <code>target</code>, so GC did not push <code>target</code> into the queue. So the pointer link from <code>o</code> to <code>target</code> is missed in GC. This can result in <code>target</code> being wrongly reclaimed despite it is live.</p>
<p>And what could go wrong if the GC marking logic doesn’t have the fence? Similarly, without the fence, the CPU can execute the <code>LOAD</code> in line 3 before the <code>STORE</code> in line 1. Then, in the following interleaving:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = white</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
</ol>
<p>Similar to above, mutator sees <code>t1 = white</code> and GC sees <code>t2 = oldValue</code>. So <code>o</code> is not added to remembered set, and <code>target</code> is not pushed into the queue, the pointer link is missed.</p>
<p>Finally, let’s analyze why the code behaves correctly if both fences are present. Unfortunately there is not a better way than manually enumerating all the interleavings. Thanks to the fences, <code>Mutator Line 1</code> must execute before <code>Mutator Line 3</code>, and <code>GC Line 1</code> must execute before <code>GC Line 3</code>, but the four lines can otherwise be reordered arbitrarily. So there are <code>4! / 2! / 2! = 6</code> possible interleavings. So let’s go!</p>
<p>Interleaving 1:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = white</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>In this interleaving, the mutator did not add <code>o</code> to remembered set, but the GC sees <code>target</code>, so it’s fine.</p>
<p>Interleaving 2:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = some old value</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
</ol>
<p>In this interleaving, GC saw the old value, but the mutator added <code>o</code> to the remembered set, so GC will eventually drain from the remembered set and scan <code>o</code> again, at which time it will see the correct new value <code>target</code>, so it’s fine.</p>
<p>Interleaving 3:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>In this interleaving, GC saw the new value <code>target</code>, nevertheless, the mutator saw <code>t1 = black</code> and added <code>o</code> to the remembered set. This is unfortunate since GC will scan <code>o</code> again, but it doesn’t affect correctness.</p>
<p>Interleaving 4:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>Interleaving 5:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] store(o.f, target)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>Interleaving 6:</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Line 1] Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 1] Store(o.f, target)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Line 3] t2 = Load(o.f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t2 = target</div>
</li>
<li>
<div style="background-color:#FFCB9A">[Mutator Line 3] t1 = Load(o.cellState)&nbsp;&nbsp;&nbsp;&nbsp;// t1 = black</div>
</li>
</ol>
<p>Same as Interleaving 3.</p>
<p>This proves that with the two <code>StoreLoadFence()</code>, our code is no longer vulnerable to the above race condition.</p>
<h4 id="Another-Race-Condition-Between-WriteBarrier-and-Marking">Another Race Condition Between WriteBarrier and Marking</h4>
<p>The above fix alone is not enough: there is another race between <code>WriteBarrier</code> and GC marking threads. Recall that in <code>WriteBarrierSlowPath</code>, we attempt to flip the object back to <code>white</code> if we saw it is not marked (this may happen during a full GC), as illustrated below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">... omitted ...</span><br><span class="line"><span class="keyword">if</span> (!isMarked(obj)) &#123;</span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">... omitted ...</span><br></pre></td></tr></table></figure>
<p>It turns out that, after setting the object <code>white</code>, we need to do a <code>StoreLoadFence()</code>, and check again if the object is marked. If it becomes marked, we need to set <code>obj-&gt;cellState</code> back to <code>black</code>.</p>
<p>Without the fix, the code is vulnerable to the following race:</p>
<ol>
<li>[Precondition] <code>o.cellState = black</code> and <code>o.isMarked = false</code></li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Check isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see false</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>[Postcondition] <code>o.cellState = white</code> and <code>o.isMarked = true</code></li>
</ol>
<p>The post-condition is bad because <code>o</code> will not be added to the remembered set in the future, despite that it needs to be (as the GC has already scanned it).</p>
<p>Let’s now prove why the code is correct when the fix is applied. Now the <code>WriteBarrier</code> logic looks like this:</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)</div>
</li>
</ol>
<p>Note that we omitted the first “Check isMarked()” line because it must be the first thing executed in the interleaving, as otherwise the <code>if</code>-check won’t pass at all.</p>
<p>The three lines in <code>WriteBarrier</code> cannot be reordered by CPU: Line 1-2 cannot be reordered because of the <code>StoreLoadFence()</code>, line 2-3 cannot be reordered since line 3 is a store that is only executed if line 2 is true. The two lines in GC cannot be reordered by CPU because line 2 stores to the same field <code>o.cellState</code> as line 1.</p>
<p>In addition, note that it’s fine if at the end of <code>WriteBarrier</code>, the object is <code>black</code> but GC has only executed to line 1: this is unfortunate, because the next <code>WriteBarrier</code> on this object will add the object to the remembered set despite it’s unnecessary. However, it does not affect our correctness. So now, let’s enumerate all the interleavings again!</p>
<p>Interleaving 1.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = false</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// not executed</div>
</li>
</ol>
<p>Object is not marked and white, OK.</p>
<p>Interleaving 2.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = false</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// not executed</div>
</li>
</ol>
<p>Object is in queue and white, OK.</p>
<p>Interleaving 3.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is in queue and black, unfortunate but OK.</p>
<p>Interleaving 4.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is in queue and black, unfortunate but OK.</p>
<p>Interleaving 5.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = false</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// not executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 6.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 7.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 8.</p>
<ol>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 9.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>Interleaving 10.</p>
<ol>
<li>
<div style="background-color:#A8B545">[GC Marking] CAS(o.isMarked, true), Store(o.cellState, white), pushed 'o' into queue</div>
</li>
<li>
<div style="background-color:#A8B545">[GC Marking] Popped 'o' from queue, Store(o.cellState, black)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] Store(o.cellState, white)</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] t1 = isMarked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// t1 = true</div>
</li>
<li>
<div style="background-color:#FFCB9A">[WriteBarrier] if (t1 == true): Store(o.cellState, black)&nbsp;&nbsp;&nbsp;// executed</div>
</li>
</ol>
<p>Object is marked and black, OK.</p>
<p>So let’s update our pseudo-code. However, I would like to note that, in JSC’s implementation, they did not use a <code>StoreLoadFence()</code> after <code>obj-&gt;cellState = white</code>. Instead, they made the <code>obj-&gt;cellState = white</code> a CAS from <code>black</code> to <code>white</code> (with memory ordering <code>memory_order_seq_cst</code>). This is stronger than a <code>StoreLoadFence()</code> so their logic is also correct. Nevertheless, just in case my analysis above missed some other race with other components, our pseudo-code will stick to their logic…</p>
<p>Mutator <code>WriteBarrier</code> pseudo-code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrier</span><span class="params">(JSCell* obj)</span> </span>&#123;</span><br><span class="line">  StoreLoadFence();            <span class="comment">// Note the fence!</span></span><br><span class="line">  <span class="keyword">if</span> (obj-&gt;cellState == black) </span><br><span class="line">    WriteBarrierSlowPath(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrierSlowPath</span><span class="params">(JSCell* obj)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (IsGcRunning()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMarked(obj)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (CompareAndSwap(</span><br><span class="line">         obj-&gt;cellState, black <span class="comment">/*from*/</span>, white <span class="comment">/*to*/</span>) == SUCCESS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMarked(obj)) &#123;</span><br><span class="line">          obj-&gt;cellState = black;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(isMarked(obj));   </span><br><span class="line">  &#125;</span><br><span class="line">  obj-&gt;cellState = white;</span><br><span class="line">  <span class="comment">// Add 'obj' to remembered set</span></span><br><span class="line">  rmbSet.push(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden/Full GC Marking phase:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty() || !rmbSet.empty()) &#123;</span><br><span class="line">  JSCell* obj = !<span class="built_in">queue</span>.empty() ? <span class="built_in">queue</span>.pop() : rmbSet.pop();</span><br><span class="line">  obj-&gt;cellState = black;       </span><br><span class="line">  StoreLoadFence();           <span class="comment">// Note the fence!</span></span><br><span class="line">  obj-&gt;ForEachChild([&amp;](JSCell* child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child-&gt;isMarked) &#123;   </span><br><span class="line">      markObject(child);</span><br><span class="line">      child-&gt;cellState = white; </span><br><span class="line">      <span class="built_in">queue</span>.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Remove-Unnecessary-Memory-Fence-In-WriteBarrier">Remove Unnecessary Memory Fence In WriteBarrier</h4>
<p>The <code>WriteBarrier</code> is now free of hazardous race conditions. However, we are executing a <code>StoreLoadFence()</code> for every <code>WriteBarrier</code>, which is a very expensive CPU instruction. Can we optimize it?</p>
<p>The idea is the following: the fence is used to protect against race with GC. Therefore, we definitely need the fence if the GC is concurrently running. However, the fence is unnecessary if the GC is not running. Therefore, we can check if the GC is running first, and only execute the fence if the GC is indeed running.</p>
<p>JSC is even smarter: instead of having two checks (one that checks if the GC is running and one that checks if the <code>cellState</code> is <code>black</code>), it combines them into a single check for the fast-path where the GC is not running and the object is <code>white</code>. The trick is the following:</p>
<ol>
<li>Assume <code>black = 0</code> and <code>white = 1</code> in the <code>cellState</code> enum.</li>
<li>Create a global variable called <code>blackThreshold</code>. This <code>blackThreshold</code> is normally <code>0</code>, but at the beginning of a GC cycle, it will be set to <code>1</code>, and it will be reset back to <code>0</code> at the end of the GC cycle.</li>
<li>Now, check if <code>obj-&gt;cellState &gt; blackThreshold</code>.</li>
</ol>
<p>Then, if the check succeeded, we know we can immediately return: the only case this check can succeed is when the GC is not running and we are <code>white</code> (because <code>blackThreshold = 0</code> and <code>cellState = 1</code> is the only situation to pass the check). This way, the fast path only executes one check. If the check fails, then we fallback to the slow path, which performs the full procedure: check if GC is running, execute a fence if needed, then check if <code>cellState</code> is <code>black</code> again. In pseudo-code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBarrier</span><span class="params">(JSCell* obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj-&gt;cellState &gt; g_blackThreshold) &#123;</span><br><span class="line">    <span class="comment">// Fast-path: the only way to reach here is when</span></span><br><span class="line">    <span class="comment">// the GC is not running and the cellState is white</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!IsGcRunning()) &#123;</span><br><span class="line">    <span class="comment">// g_blackThreshold is 0, so our object is</span></span><br><span class="line">    <span class="comment">// actually black, we need to go to WriteBarrierSlowPath</span></span><br><span class="line">    WriteBarrierSlowPath(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// GC is running so we need to execute the fence </span></span><br><span class="line">    <span class="comment">// and check cellState again</span></span><br><span class="line">    StoreLoadFence(); </span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;cellState == black) &#123;</span><br><span class="line">      WriteBarrierSlowPath(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that there is no race between <code>WriteBarrier</code> and GC setting/clearing <code>IsGcRunning()</code> flag and changing the <code>g_blackThreshold</code> value, because the mutator is always stopped at a safe point (of course, halfway inside <code>WriteBarrier</code> is not a safe point) when the GC starts/finishes.</p>
<h4 id="“Obstruction-Free-Double-Collect-Snapshot”">“Obstruction-Free Double Collect Snapshot”</h4>
<p>Concurrent GC also introduced new complexities for the <code>ForEachChild</code> function used by GC marking phase to scan all objects referenced by a certain object. Each Javascript object has a <code>Structure</code> (aka, hidden class) that describes how the content of this object shall be interpreted into object fields. Since the GC marking phase is run concurrently with the mutator, and the mutator may change the <code>Structure</code> of the object, and may even change the size of the object’s butterfly, GC must be sure that despite the race conditions, it will never crash by dereferencing invalid pointers and never miss to scan a child. Using a lock is clearly infeasible for performance reasons. JSC uses a so-called <em>obstruction-free double collect snapshot</em> to solve this problem. Please refer to the <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/" target="_blank" rel="noopener">Webkit GC blog post</a> to see how it works.</p>
<h3 id="Some-Minor-Design-Details-and-Optimizations">Some Minor Design Details and Optimizations</h3>
<p>You might find this section helpful if you want to actually read and understand the code of JSC, but otherwise feel free to skip it: these details are not centric to the design, and are not particularly interesting either. I mention them only to bridge the gap between the GC scheme explained in this post and the actual implementation in JSC.</p>
<p>As explained earlier, each <code>CompleteSubspace</code> owns a list of <code>BlockDirectory</code> to handle allocations of different sizes; each <code>BlockDirectory</code> has an active block <code>m_currentBlock</code> where it allocates from, and it achieves this by holding a free list of all available cells in the block. But how does it work exactly?</p>
<p>As it turns out, each <code>BlockDirectory</code> has a <code>cursor</code>, which is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.cpp.html#_ZN3JSC14LocalAllocator5resetEv">reset</a> to point at the beginning of the block list at the end of an eden or full GC cycle. Until it is reset, it can only move forward. The <code>BlockDirectory</code> will <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectory.cpp.html#_ZN3JSC14BlockDirectory22findBlockForAllocationERNS_14LocalAllocatorE">move the cursor forward</a>, until it finds a block containing available cells, and allocate from it. If the cursor reaches the end of the list, it will attempt to <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.cpp.html#195">steal a 16KB block</a> from another <code>BlockDirectory</code> and allocate from it. If that also failed, it will allocate a new 16KB block from OS and allocate from it.</p>
<p>I also mentioned that a <code>BlockDirectory</code> uses a free list to allocate from the currently active block <code>m_currentBlock</code>. It’s important to note that in the actual implementation of JSC, the cells in <code>m_currentBlock</code> does not respect the rule for <code>isNew</code> bit. Therefore, to check liveness, one either need to do a special-case check to see if the cell is from <code>m_currentBlock</code> (for example, see <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/HeapCell.cpp.html#_ZN3JSC8HeapCell6isLiveEv">HeapCell::isLive</a>), or, for the GC<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>, stop the mutator, destroy the free list (and populate <code>isNew</code> in the process), do whatever inspection, then rebuild the free list and resume the mutator. The latter is implemented by <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle14stopAllocatingERKNS_8FreeListE">two</a> <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle16resumeAllocatingERNS_8FreeListE">functions</a> named <code>stopAllocating()</code> and <code>resumeAllocating()</code>, which are automatically called whenever the world is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/Heap.cpp.html#_ZN3JSC4Heap16stopThePeripheryENS_11GCConductorE">stopped</a> or <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/Heap.cpp.html#_ZN3JSC4Heap18resumeThePeripheryEv">resumed</a>.</p>
<p><a name="isNewAndAllocateBit"></a>The motivation of allowing <code>m_currentBlock</code> to not respect the rule for <code>isNew</code> is (a tiny bit of) performance. Instead of manually setting <code>isNew</code> to <code>true</code> for every allocation, a block-level bit <code>allocated</code> (aggregated as a bitvector in <code>BlockDirectory</code>) is used to indicate if a block is full of live objects. When the <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.cpp.html#_ZN3JSC11MarkedBlock6Handle18didConsumeFreeListEv">free list becomes empty</a> (i.e., the block is fully allocated), we simply set <code>allocated</code> to <code>true</code> for this block. When querying cell liveness, we <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlockInlines.h.html#101">check this bit first</a> and directly return true if it is set. The <code>allocated</code> bitvector is <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectory.cpp.html#252">cleared at the end of each GC cycle</a>, and since the global logical version for <code>isNew</code> is also bumped, this effectively clears all the <code>isNew</code> bits, just as we desired.</p>
<p>JSC’s design also support the so-called <em>constraint solver</em>, which allows specification of implicit reference edges (i.e., edge not represented as pointer in the object). This is mainly used to support Javascript interaction with DOM. This part is not covered in this post.</p>
<p>Weak reference has multiple implementations in JSC. The general (but less efficient) implementation is <code>WeakImpl</code>, denoting a weak reference edge. The data structure managing them is <code>WeakSet</code>, and you can see it in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/MarkedBlock.h.html#JSC::MarkedBlock::Handle::m_weakSet">every block footer</a>, and in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/PreciseAllocation.h.html#JSC::PreciseAllocation::m_weakSet">every PreciseAllocation GC header</a>. However, JSC also employs more efficient specialized implementations to handle the weak map feature in Javascript. The details are not covered in this post.</p>
<p>In JSC, objects may also have destructors. There are three ways the destructors are run. First, when we begin allocating from a block, destructors of the dead cells are run. Second, the <code>IncrementalSweeper</code> periodically scans the blocks and runs destructors. Finally, when the VM shuts down, the <code>lastChanceToFinalize()</code> function is called to ensure that all destructors are run at that time. The details of <code>lastChanceToFinalize()</code> are not covered in this post.</p>
<p>JSC employs a conservative approach for pointers on the stack and in registers: the GC uses UNIX signals to suspend the mutator thread, so it can copy its stack contents and CPU register values to search for data that looks like pointers. However, it’s important to note that UNIX signal is <strong>not</strong> used to suspend the execution of the mutator: the mutator always <strong>actively</strong> suspends itself at a safe point. This is critical, as otherwise it could be suspended at weird places, for example, in a <code>HeapCell::isLive</code> check after it has read <code>isNew</code> but before it has read <code>isMarked</code>, and then GC did <code>isNew |= isMarked, isMarked = false</code>, and boom. So it seems like the only reason to suspend the thread is for the GC to get the CPU register values, including the <code>SP</code> register value so the GC knows where the stack ends. It’s unclear to me if it’s possible to do so in a cooperative manner instead of using costly UNIX signals.</p>
<h3 id="Acknowledgements">Acknowledgements</h3>
<p>I thank Saam Barati from JSC team for his enormous help on this blog post. Of course, any mistakes in this post are mine.</p>
<hr>
<h4 id="Footnotes">Footnotes</h4>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Brief stop-the-world pause is still required at the start and end of each GC cycle, and may be intentionally performed if the mutator thread (i.e. the thread running Javascript code) is producing garbage too fast for the GC thread to keep up with. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>The actual allocation logic is implemented in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.h.html#JSC::LocalAllocator">LocalAllocator</a>. Despite that in the code <code>BlockDirectory</code> is holding a linked list of <code>LocalAllocator</code>, (at time of writing, for the codebase version linked in this blog) the linked list always contains exactly one element, so the <code>BlockDirectory</code> and <code>LocalAllocator</code> is one-to-one and can be viewed as an integrated component. This relationship might change in the future, but it doesn’t matter for the purpose of this post anyway. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Since the footer resides at the end of a 16KB block, and the block is also 16KB aligned, one can do a simple bit math from any object pointer to access the footer of the block it resides in. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Similar to that per-cell information is aggregated and stored in the block footer, per-block information is aggregated as bitvectors and stored in <code>BlockDirectory</code> for fast lookup. Specifically, two bitvectors <code>empty</code> and <code>canAllocateButNotEmpty</code> track if a block is empty, or partially empty. The <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectoryBits.h.html#_M/FOR_EACH_BLOCK_DIRECTORY_BIT">code</a> is relatively confusing because the bitvectors are <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/BlockDirectoryBits.h.html#JSC::BlockDirectoryBits::Segment">layouted in a non-standard way</a> to make resizing easier, but conceptually it’s just one bitvector for each boolean per-block property. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>While seemingly straightforward, it is not straightforward at all (as you can see in the code). The free cells are marked free by the GC, and due to concurrency and performance optimization the logic becomes very tricky: we will revisit this later. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>In fact, it also <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/LocalAllocator.cpp.html#195">attempts to steal</a> blocks from other allocators, and the OS memory allocator may have <a href="https://sillycross.github.io/r/WebKit/WTF/Headers/wtf/Gigacage.h.html">some special requirements</a> required for the VM, but we ignore those details for simplicity. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>In the current implementation, the list of sizes (byte) are 16, 32, 48, 64, 80, then <code>80 * 1.4 ^ n</code> for <code>n &gt;= 1</code> up to about 8KB. Exponential growth guarantees that the overhead due to internal fragmentation is at most a fraction (in this case, 40%) of the total allocation size. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>An interesting implementation detail is that <code>IsoSubspace</code> and <code>CompleteSubspace</code> always return memory aligned to 16 bytes, but <code>PreciseAllocation</code> always return memory address that has reminder 8 module 16. This allows identifying whether an object is allocated by <code>PreciseAllocation</code> with a simple bit math. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>JSC has another small optimization here. Sometimes a <code>IsoSubspace</code> contains so few objects that it’s a waste to hold them using a 16KB memory page (the block size of <code>BlockDirectory</code>). So the first few memory pages of <code>IsoSubspace</code> use the so-called “lower-tier”, which are smaller memory pages allocated by <code>PreciseAllocation</code>. In this post, we will ignore this design detail for simplicity. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Memory of an <code>IsoSubspace</code> is only used by this <code>IsoSubspace</code>, never stolen by other allocators. As a result, a memory address in <code>IsoSubspace</code> can only be reused to allocate objects of the same type. So for any type <code>A</code> allocated by <code>IsoSubspace</code>, even if there is a use-after-free bug on type <code>A</code>, it is impossible to allocate <code>A</code>, free it, allocate type <code>B</code> at the same address, and exploit the bug to trick the VM into interpreting an integer field in <code>B</code> controlled by attacker as a pointer field in <code>A</code>. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>In some GC schemes, an eden object is required to survive two (instead of one) eden GC to be considered in old space. The purpose of such design is to make sure that any old space object is at least one eden-GC-gap old. In contrast, in JSC’s design, an object created immediately before an eden collection will be considered to be in old space immediately, which then can only be reclaimed via a full GC. The performance difference between the two designs is unclear to me. I conjecture JSC chose its current design because it’s easier to make concurrent. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>There is one additional color <code>Grey</code> in <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/heap/CellState.h.html#JSC::CellState">the code</a>. However, it turns out that <code>White</code> and <code>Grey</code> makes no difference (you can verify it by grepping all use of <code>cellState</code> and observe that the only comparison on <code>cellState</code> is checking if it is <code>Black</code>). The comments explaining what the colors mean are also a bit outdated. This is likely a historical artifact. In my opinion JSC should really clean it up and update the comment, as it can easily cause confusion to readers who intend to understand the design. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>The bit is actually called <code>isNewlyAllocated</code> in the code. We shorten it to <code>isNew</code> for convenience in this post. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p><em>Safe point</em> is a terminology in GC. At a <em>safe point</em>, the heap and stack is in a coherent state understandable by the GC, so the GC can correctly trace out which objects are dead or live. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>For <code>PreciseAllocation</code>, all allocated objects are chained into a linked list, so we can traverse all objects (live or dead) easily. This is not efficient: we will explain the optimizations for <code>CompleteSubspace</code> later. <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Keep in mind that while this is true for now, as we add more optimizations to the design, this will no longer be true. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Note that we push the old space object into the queue, not the eden object, because this pointer could have been overwritten at the start of the GC cycle, making the eden object potentially collectable. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Also note that all objects dead before this GC cycle, i.e. the free cells of a block in <code>CompleteSubspace</code>, still have <code>isNew = false</code> and <code>isMarked = false</code>, as desired. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Recall that under generational hypothesis, most objects die young. Therefore, that “all objects in an eden block are found dead during eden GC” is something completely plausible. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>In JSC, the version is stored in a <code>uint32_t</code> and they have a bunch of logic to handle the case that it overflows <code>uint32_t</code>. In my humble opinion, this is an overoptimization that results in very hard-to-test edge cases, especially in a concurrent setting. So we will ignore this complexity: one can easily avoid these by spending 8 more bytes per block footer to have <code>uint64_t</code> version number instead. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Note that any number of eden GC cycles may have run between the last full GC cycle and the current full GC cycle, but eden GC does not bump mark version. So for any object born before the last GC cycle (no matter eden or full), the <code>isMarked</code> bit honestly reflect if it is live, and we will accept the bit as its mark version must be off-by-one. For objects born after the last GC cycle, it must have a latest <code>isNew</code> version, so we can know it’s alive through <code>isNew</code>. In both cases, the scheme correctly determines if an object is alive, just as desired. <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>And probably not: first, true sharing and false sharing between GC and mutator can cause slowdown. Second, as we have covered before, JSC uses a Time-Space Scheduler to prevent the mutator from allocating too fast while the GC is running. Specifically, the mutator will be intentionally suspended for at least 30% of the duration. So as long as the GC is running, the mutator suffers from an 30%-or-more “performance tax”. <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>The real story is a bit more complicated. JSC actually reuse the same VM for different Javascript scripts. However, at any moment, at most one of the script can be running. So technically, there are multiple mutually-exclusive mutator threads, but this doesn’t affect our GC story. <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>The GC needs to inspect a lot of cells, and its logic is already complex enough, so having one less special-case branch is probably beneficial for both engineering and performance. <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
      

    

    <footer class="article-footer">
    <!--
      <a data-url="https://sillycross.github.io/2022/06/02/2022-06-02/" data-id="clheiynn7000jc2onfc7e2bgs" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
    -->
      
      

    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="../../../05/31/2022-05-31/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">NP70PNP + Ubuntu Tweak Notes</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="../../11/2022-06-11/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">Bizarre Performance Characteristics of Alder Lake CPU</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  


  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../../../../archives/2022/">2022</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="../../../../archives/2021/">2021</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list-recent-posts">
      
        <li>
          <a href="../../../11/22/2022-11-22/">Building the fastest Lua interpreter.. automatically!</a>
        </li>
      
        <li>
          <a href="../../../10/02/2022-10-02/">Pitfalls of using C++ Global Variable Constructor as a Registration Mechanism</a>
        </li>
      
        <li>
          <a href="../../../07/18/2022-07-18/">How to check if a real number is an integer in C++?</a>
        </li>
      
        <li>
          <a href="../../11/2022-06-11/">Bizarre Performance Characteristics of Alder Lake CPU</a>
        </li>
      
        <li>
          <a href="">Understanding GC in JSC From Scratch</a>
        </li>
      
    </ul>
  </div>




        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2023 Haoran Xu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>-->

<script src="../../../../js/bootstrap/bootstrap.min.js"></script>



  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
 

</body>
</html>
